{"pages":[],"posts":[{"title":"Clutch 砸壳","text":"工具 Clutch 一台越狱手机（实验机为 iPhone5S，系统 iOS 8.1.3） 终端 具体操作安装 Clutch推荐使用 Clutch-2.0.4 版本。 12$ git clone https://github.com/KJCracks/Clutch Clutch-2.0.4$ cd Clutch-2.0.4 获取 Clutch.app 的可执行文件方式一：通过 xcodebuild 指令获取 cd 到 clone 下来的 Clutch 目录下，执行： 1$ xcodebuild -project Clutch.xcodeproj -configuration Release ARCHS=&quot;armv7 armv7s arm64&quot; build 生成出来的 Unix 可执行文件 clutch 就在当前目录下。 方式二：通过 Clutch.app 包获取 打开 Clutch.xcodeproj ，编译成功之后，在 Products 目录下找到 Clutch.app，在包内获取 Clutch.app 的可执行文件 clutch。 将可执行文件拷贝到手机上: 1scp &lt;Clutch Executable directory&gt; root@&lt;your.device.ip&gt;:/usr/bin/ 使用 ssh 连接手机打开终端界面，使用 ssh 连接手机： 12$ ssh root@&lt;your.device.ip&gt;$ clutch -i 终端输出： Installed apps:1: Flashlight &lt;com.bigblueclip.led&gt;2: 微信 &lt;com.tencent.xin&gt;3: QQ同步助手 &lt;com.tencent.QQPim&gt; 根据列表中显示的包名进行砸壳，这里以微信为例 1$ clutch -d com.tencent.xin 可以看到 Clutch 砸壳后的 ipa 文件放到了/private/var/mobile/Documents/Dumped/目录下。修改成一个简单的名字，然后拷贝回电脑： 12$ mv /private/var/mobile/Documents/Dumped/com.tencent.xin-iOS8.0-\\(Clutch-2.0.4\\).ipa /private/var/mobile/Documents/Dumped/wechat.ipa$ scp root@&lt;your.device.ip&gt;:/private/var/mobile/Documents/Dumped/wechat.ipa ~/Desktop 砸壳完毕。","link":"/post/app-smash-by-clutch/"},{"title":"使用位段提高委托模式下的程序效率","text":"什么是位段？位段 (bit-field) 是以位为单位来定义结构体(或联合体)中的成员变量所占的空间。含有位段的结构体称为位段结构。优点：采用位段结构既能够节省空间，又方便于操作。 拓展链接：什么是位段？ 分析在实现委托模式时，如果协议中的方法是可选的，经常需要写代码来判断某个委托对象是否能响应特定的选择子，那么就会出现下列代码： 123if ([_delegate respondsToSelector:@selector(personDidSomething:)]) { [_delegate personDidSomething:something];} 但是在委托对象本身没变的情况下，如果频繁执行此操作的话，那么除了第一次检测结果是有用之外，后续的检测可能都是多余的。在这里，可以把委托对象是否能响应某个协议方法这一信息缓存起来，以优化代码执行的效率。 123456@class Man;@protocol ManDelegate &lt;NSObject&gt;@optional- (void)man:(Man)man playGame:(NSString *)game;- (void)man:(Man)man eatFood:(NSString *)food;@end 我们可以使用结构体来存储某个代理是否用 respondsToSelector 方法检测过。先在 Man 类下声明一个结构体： 12345@interface Man () { struct { unsigned int playGame : 1; }_delegateFlags;} 在上述结构体中， playGame 位段占用 1 个二进制位，它可以表示 0 或 1 这两个值。我们可以通过下面的方法操作上述两个位段。 1234//set _delegateFlags.playGame = 1;//getif (\u0010!_delegateFlags.playGame) {} 实现缓存功能所用的代码可以写在 delegate 属性所对应的设置方法里： 1234- (void)setDelegate:(id&lt;ManDelegate&gt;)delegate { _delegate = delegate; _delegateFlags.playGame = [delegate respondsToSelector:@selector(man:playGame:)];} 这样的话，每次调用 delegate 的相关方法之前，就不用检测委托对象是否能响应给定的选择子了，而是直接查询结构体里的标识。 优化前： 123if ([_delegate respondsToSelector:@selector(man:playGame:)]) { [_delegate man:self playGame:game];} 优化后： 123if (_delegateFlags.playGame) { [_delegate man:self playGame:game];} 在相关代理方法需要调用多次时，这种缓存优化策略还是很有必要的。","link":"/post/bit-segemnt/"},{"title":"真机下获取 Log 日志","text":"当使用 Xcode 进行调试的时候，开发者可以通过 Xcode 的控制台查看输出的 Log 日志，方便进行程序调试。实际上，在脱离了 Xcode 的情况下，调用 Log 依旧有用。下面将介绍2种获取真机上 Log 日志的方案。 控制台查看日志MAC 上默认提供了一款名为 控制台 的应用，它会输出 MAC 以及已连接的 iPhone 上所有的日志信息。 操作步骤手机连接到 MAC 上，然后打开 控制台.app , 在左侧列表里找到连接设备，右边列表里就会输出手机上的所有日志。在上方搜索栏里输入 App的二进制名，选择 进程，过滤出 App 的输出日志。 本地查看日志要完成这个功能需要实现以下两步： 写日志到沙盒 沙盒导出文件 写日志到沙盒Xcode 的日志显示原理其实是将日志写入到一个特定文件中存在本地，然后再显示到我们的 console 中。在真机环境上，如果脱离了 Xcode ，日志将被写入到手机的一个特定目录下。我们要做到就是重定向文件流，让日志写到我们指定到目录下。要实现这一点，我们得先了解以下函数 freopen freopen 函数freopen 是被包含于 C 标准库头文件 &lt;stdio.h&gt; 中的一个函数，用于重定向输入输出流。该函数可以在不改变代码原貌的情况下改变输入输出环境，但使用时应当保证流是可靠的。定义如下： 1FILE *freopen(const char *filename, const char *mode, FILE *stream) 形参说明:filename需要重定向到的文件名或文件路径。mode代表文件访问权限的字符串。例如，r 表示只读访问、w 表示只写访问、a 表示追加写入、+表示读和写。stream需要被重定向的文件流。例如，stdin 表示标准输入流、stdout 表示标准输出流、stderr表示标准错误输出流 实现原理我们输出日志通常会调用 NSLog 和 printf。NSLog 内部定向的文件流是 stderr，而printf(…) 的实现等价于调用了fprintf(stdout, …)，因此我们只需调用 freopen 重定向文件流 stderr 和 stdout，在合适到时机关闭文件流，让日志顺利写入到我们指定的沙盒文件中即可。重定向的代码如下： 1234567891011/// 将log的输出信息写入到沙盒的Documents目录下，并输出为log文件- (void)redirectLogToDocumentFolder { /// 存于Document文件夹 NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES); NSString *documentDirectory = [paths objectAtIndex:0]; NSString *fileName = [NSString stringWithFormat:@\"%@.log\",[[NSDate alloc] initWithTimeIntervalSinceNow:8*3600]]; NSString *logFilePath = [documentDirectory stringByAppendingPathComponent:fileName]; /// 将log输入到文件 stdout是输出printf的内容，stderr是输出NSLog的内容 freopen([logFilePath cStringUsingEncoding:NSASCIIStringEncoding],\"a+\",stdout); freopen([logFilePath cStringUsingEncoding:NSASCIIStringEncoding],\"a+\",stderr);} 上述的方法一般在程序的入口调用，即： 1234- (BOOL)application(UIApplication *)application didFinishLaunchingWithOptions(NSDictionary *)launchOptions { /// 保存真机调试日志文件到沙盒 Documents 目录 [self redirectLogToDocumentFolder];} 合适的写入时机stderr 的文件流是随时写入的，而 stdout 需要你找一个合适的时机关闭文件流写入，这里我们选择程序即将崩溃时。代码如下： 1234- (void)applicationWillTerminate:(UIApplication *)application { /// 关闭文件流，让日志最终写入到指定目录 fclose(stdout);} 查看日志文件手机连接上 MAC，然后打开 Xcode ，根据路径 Xcode -&gt; Window -&gt; Devices and Simulators 进入到如下页面。 在 INSTALLED APPS 中找到刚才输出日志的 App 包，点击左下角的齿轮键 ，在弹出菜单中选择 Download Container... ，就可以获取 App 沙盒信息，从 Documents 中找到刚才输出的日志。 NSLog 的不足在平时测试开发的时候我们发现，当 NSLog 的输出信息超过一定长度时，数据会被截断。为了弥补这一缺点，我们试着使用 printf 去打印。但是 printf 无法被 console 捕获，因此采用了方案二中的沙盒保存日志方案弥补这个不足。","link":"/post/get-log-in-device/"},{"title":"浅析 HTTPS","text":"一直对于 HTTPS 的概念理解的不透彻，与人探讨之时也会因为并没有完全弄懂而一时语塞。因此下定决心去搞懂这个概念。HTTPS 是在 HTTP 与某一个协议的混合，这个协议一般指的是 TLS（更早的有 SSL ）。因为要先弄清楚什么是 HTTPS ，就得先弄清楚什么是 HTTP 。 HTTPHTTP（HyperText Transport Protocol）是超文本传输协议的缩写，它用于传送 WWW 方式的数据。 HTTP 协议采用了请求/响应模型。客户端向服务器发送一个请求，请求头包含请求的方法、 URL 、协议版本、以及包含请求修饰符、客户信息和内容类似于 MIME 的消息结构。服务器以一个状态行作为响应，响应的内容包括消息协议的版本，成功或者错误编码加上包含服务器信息、实体元信息以及可能的实体内容。 简单的过程可以归纳成 DNS 解析，请求 DNS 服务器，获取域名对应的 IP 地址。 与服务端建立连接，包括 tcp 三次握手，安全协议同步流程。 连接建立完成，发送和接收数据，解码数据。 HTTP 的隐患HTTP 的一个简单的现实场景： 假设你坐在一个教室里，你现在非常想把某个信息传递给教室里的另一个人，一般来说，会选择传纸条。传纸条这个比喻其实非常正确，这就是互联网的一个基础协议 TCP/IP 协议基本的工作模式。而通常，HTTP 协议的数据是使用 TCP/IP 协议进行发送的。HTTP 指的是你在纸条上写明你要传送的目的地是哪个同学的座位，然后再是要传递的内容。途径的同学拿到纸条后根据纸条上显示的地址依次传过去就好了。这样要面临的第一个问题就是：途经的同学可以完全知道你写了什么。也就是说 HTTP 协议容易在传输数据过程中被人窃听，即在同一个网络下或者是途径的路由上的攻击者可以偷窥到你传输的内容。 解决方案对称加密 既然容易在传输过程中被窃听，那么很容易想到的办法就是给数据进行加密。最简单的办法就是双方约定一个暗号，进行加密。为了让接收端能解析发送端发送的数据，一般会采用对称加密的算法，如 AES 。这种算法一般会有个秘钥，用于对数据进行加密，接收到后对数据进行解密，完成通信。但是这里存在一个问题，这种算法存在密钥 key ，如果放在传输的数据中，就容易在传输的过程中被人拿来进行数据解密，依旧无法保障数据安全。 非对称加密 为了保证 key 只要发送方和接收方知道。于是就想到了另一类加密算法-非对称算法，如 RSA 。这种加密方式一般是生成一对密钥 (k1, k2)。凡是 k1 加密的数据， k1 自身不能解密，而需要 k2 才能解密；凡是 k2 加密的数据，k2 不能解密，需要 k1 才能解密。于是数据就可以这样传输：用 RSA 技术生成了一对 k1、k2，你把 k1 用明文发送了出去，路经有人或许会截取，但是没有用，k1 加密的数据需要用 k2 才能解密。而此时， k2 在你自己的手里。 k1 送达目的地后，目的地的人会去准备一个接下来用于对称加密传输的密钥 key，然后用收到的 k1 把 key 加密了，把加密好的数据传回来。路上的人就算截取到了，也解密不出 key 。等到了你自己手上，你用手上的 k2 把用 k1 加密的 key 解出来。这样就能保证只有发送方和接收方知道堆成加密的秘钥 key 了。 为什么不用非对称加密直接加密数据？因为非对称加密对生成和加密的消耗时间比较长，为了节省双方的计算时间，通常只用它来交换密钥，而非直接用来传输数据。 非对称加密的隐患非对称加密其实存在一个隐患，那就是存在”中间人攻击”。为了简化这一过程，我们把发送端、中间人、接收端依次设为 A 、 M 、 B 。 A 和 B 进行秘钥交换的时候，经过了中间人 M 。 M 知道要进行秘钥交换，于是将数据扣下。对于 A ，自己伪造了一个对称秘钥 key ，将 A 发来对 k1 进行加密，发还给了 A 。对于 B ， M 模拟 A 的做法，用非对称加密算法生成了一个 k1 ，发送给了 B ，代替 A 与 B 完成了通信。这样一来， M 就知道 A 和 B 传输的所有数据了。 HTTPSHTTPS 是如何解决非对称加密的隐患的？这里引入一个叫 CA 的东西。它是一些非常权威的专门用于认证一个网站合法性的组织。服务商可以向他们申请一个证书，使得他们建立安全连接时可以带上 CA 的签名。而 CA 的安全性由操作系统或浏览器来认证。你的 Windows 、 Mac 、 Linux 、 Chrome 、 Safari 等会在安装时带上一个他们认为安全的 CA 证书列表。如果和你建立安全连接的人带着这些人的签名，那么认为这个安全连接是安全的，没有遭到中间人攻击。但世界上没有绝对的安全，一旦 CA 证书出了问题，就容易被用来进行攻击，因此还是存在安全隐患。但是这已经算是较安全的做法，相信今后还会有更先进的做法来解决这个问题。 参考链接 HTTP 协议详解 HTTPS 是如何保证安全的？移动 APP 网络优化概述","link":"/post/https/"},{"title":"Shell 脚本打 ipa 包","text":"在 iOS 开发中，我们经常需要上传 ipa 包。公司配置的电脑打包速度很慢（看机子和项目大小，反正公司配的苹果盒子很慢，而且每一步都要手点），打包时基本不能做任何其他事情（很卡），极大的浪费了时间。偶然间听说了 Shell 脚本可以帮我们很方便的解决这个问题，看了一篇文章之后，特此记录一下 Shell 打包的流程以及中间遇到的坑。 准备工作 准备要打包的项目，在苹果开发者网站上下载打包用到的证书，这里打测试包作为演示，就下载 adhoc 证书进行测试。下载 adhoc 证书并运行，然后在项目中选中 Targets -&gt; General -&gt; Signing ，勾选 Automatically manage signing ,把 team 选为该证书对应的开发者账号。 下载ReleaseDir，将 ReleaseDir 文件夹，放到跟所要打包的项目的根目录（ShellPackageDemo）同级别的目录下。 打开 ReleaseDir 文件夹中的 ExportOptions.plist 文件，这里的四个选项是对包的设置。 12345** ExportOptions.plist 文件参数说明 **compileBitcode：不上架App Store，Xcode是否启用Bitcode重新编译，默认为YES。method：归档类型，包括app-store、ad-hoc、package、enterprise、development以及developer-id。uploadBitcode：上线App Store是否开启Bitcode，默认为YES。uploadSymbols：上线App Store，是否开启符号序列化，这是与查crash相关的，默认为YES。 因此我们对 ExportOptions.plist 做如下设置： 在使用下列方法前，请先使用 Xcode 成功打包一次。（先让用户授权对 Xcode 使用钥匙串中的证书） 调用方法 打开终端，cd 至 ReleaseDir 下。假如电脑之前装了 cocoapods (其他有切换过 ruby 环境的操作也算)，请先在终端运行： 1rvm use system 将 ruby 切成系统的。 根据项目具体情况在终端运行下列对应的命令 12./release.sh shellPackageDemo -w -e -v 1.0.0 -b 1.0.0 //使用了cocoapods./release.sh shellPackageDemo -e -v 1.0.0 -b 1.0.0 //未使用cocoapods 1234567891011调用格式:参数说明：&lt;Project directory name&gt; 第一个参数：所要打包的项目的根目录文件夹名称-w workspace打包，不传默认为project打包-s &lt;Name&gt; 对应workspace下需要编译的scheme（不传默认取xcodeproj根目录文件名）-e 打包前是否先编译工程（不传默认不编译）-d 工程的configuration为 Debug 模式，不传默认为Release-a 打包，Version版本号自动＋1（针对多次打测试包时的版本号修改）-b &lt;Build Num&gt; Build版本号，指定项目Build号-v &lt;Version Num&gt; Version版本号，指定项目Version号参数-a 与 -v 互斥，只能选择传其中之一 演示 demo 未使用 cocoapods ，因此运行： 1./release.sh shellPackageDemo -e -v 1.0.0 -b 1.0.0 得到 ipa 包。 运行结果截图","link":"/post/ipa-package-by-shell-script/"},{"title":"Git 工作流指南","text":"Git 工作流（Git Workflows）的本质问题是有效的项目流程管理和高效的开发协同约定。 任务管理在 GitLab 中有以下两种任务管理的方式： milestone 一个迭代版本对应一个milestone 一组可被归类的任务可以是一个milestone 可以设置 dead line issue 所有工作可以通过 issue 体现，例如： feature 开发、设计方案制定、问题讨论等 可以将这些 issue 继续拆分成针对开发过程的 issue 一个 MR 对应一个 issue Issue 需要在 MR + 3 合并后方可 merge Merge Request 创建 创建 MR 时如果有代码冲突，需手动解决后再让他人 review 谁创建的 MR 谁负责 Accept，创建者应该 Assign 给自己 约定 +1 表示同意合并，-1表示不允许合并 加入被 review 过的代码出现线上故障，+1 的人同等责任 MR 合并后才允许提测，并关闭 jira 中的 Bug 紧急发布无人 review 时，向上级报告后允许事后 MR 一次 MR 的代码数量控制在 200 行以内 分支管理正确分支包含基线分支和 issue 分支，MR 就是把 issue 分支合并到基线分支。 以客户端 Branch 为例 日常开发 通常在 master 分支进行迭代开发 所有 issue 通过创建临时分支进行开发，MR 后回 master 发布后需要在最后一个 commit 上打 tag 一次送测也需要一个 tag，命名上要和发布 tag 加以区分，例如 1.0.1A 并行开发 从上个发布 tag 创建一个用于并行开发的基线分支，在该分支为 issue 创建临时分支进行开发， MR 后回 master 如在基线分支未完成前产生了新的发布 tag，需要将该 tag 的代码合并到基线分支 发布后合并回 master 热修复 从对应的 tag 拉一个分支来进行 hotfix commit 发布后需打上 tag，合并后回 master 维护分支 确保一个仓库下仅有一个维护分支，清理及合并历史分支 如果无法合并历史分支，可以采用“空合并”（即产生一个 merge 但不做任何修改） 适当使用 rebase，绝不在公共分支上使用它 Git 常用指令创建仓库创建新仓库： 123git init # 将当前的目录转换成一个 Git 仓库git init &lt;directory&gt; # 创建一个名为 directory，只包含 .git 子目录的空目录。git init --bare &lt;directory&gt; # 创建一个名为 directory 的共享仓库 创建一个本地仓库的克隆版本： 1git clone /path/to/repository 拉取远端服务器上的仓库： 12git clone username@host:/path/to/repository # 通过 SSHgit clone https:/path/to/repository.git # 通过 https 查看仓库的状态以下的每一步，都可以通过下面这个指令来查看工作目录和缓存区： 1git status # 这一命令会列出已缓存、未缓存、未追踪的文件 而下面这类命令用于查看项目历史的基本工具： 123456789git log # 显示完整的项目历史，如果输出超过一屏，用空格键来滚动，按 q 退出git log -n &lt;limit&gt; # 只会显示 &lt;limit&gt; 个提交git log --oneline # 将每个提交压缩到一行git log --stat # 除了项目历史信息之外，包含哪些文件被更改了，以及每个文件相对的增删行数git log -p # 显示每个提交全部的差异（diff）git log --author=&quot;&lt;pattern&gt;&quot; # 搜索特定作者的提交，&lt;pattern&gt; 可以是字符串或正则表达式git log &lt;since&gt;..&lt;until&gt; # 只显示发生在 &lt;since&gt; 和 &lt;until&gt; 之间的提交。&lt;&gt;参数可以是任何一种引用git log &lt;file&gt; # 只显示包含特定文件的提交git log --graph --decorate --oneline # --graph 标记会绘制一幅字符组成的图形，左边是提交，右边是提交信息。--decorate 标记会加上提交所在的分支名称和标签。--oneline 标记将提交信息显示在同一行。 添加与提交git add 命令主要用于把我们要提交的文件的信息添加到索引库中。 12345678910git add &lt;path&gt; # 把 &lt;path&gt; 添加到索引库中，&lt;path&gt; 可以是文件也可以是目录git add . # 将所有修改添加到暂存区git add * # Ant风格添加修改git add *filetype # 将所有以 filetype 结尾的文件的所有修改添加到暂存区git add filename*. # 将所有以 filename 开头的文件的修改添加到暂存区。如:filename.h,filename.m...git add filename? # 将所有以 filename 开头，且后面只有一位的文件的修改提交到暂存区git add -A # 将所有跟踪文件中被修改过或已删除文件和所有未跟踪的文件信息添加到索引库git add -i # 进入交互式，查看所有修改过或已删除文件但没有提交的文件git add -p # 进入补丁模式，可以选择文件的一部分加入到下次提交缓存git add -u # 查看所有 tracked 文件中被修改过或已删除文件的信息添加到索引库 这是 git 基本工作流程的第一步。使用如下命令以实际提交改动： 1git commit -m &quot;commit message&quot; 推送改动commit 后文件的改动已经在本地仓库的 HEAD 中了。执行如下命令以将这些改动提交到远端仓库： 1git push origin master 你可以把 master 换成你想要推送的任何分支。 如果你还没有克隆现有仓库，并欲将你的仓库连接到某个远程服务器，可以使用如下命令添加： 1git remote add origin &lt;server&gt; 检出之前的提交git checkout 这个命令有三个不同的作用：检出文件、检出提交和检出分支。常规用法有： 123git checkout master # 回到 master 分支git checkout &lt;commit&gt; &lt;file&gt; # 将工作目录中的 &lt;file&gt; 文件变成 &lt;commit&gt; 中文件的拷贝，并将它加入缓存区git checkout &lt;commit&gt; # 更新工作目录中的所有文件，使得和某个特定提交中的文件一致 回滚错误的修改回滚有 revert 和 reset 两种做法，注意这两类的区别： git revert一种安全的方式。用来撤销一个已经提交的快照。它是通过搞清楚如何撤销这次提交引入的更改，并在最后加上一个撤销了更改的新提交，而不是从项目历史中移除这次提交。 用法： 1git revert &lt;commit&gt; git reset一种危险的方式。使用这个命令来重设更改时，我们无法获得原来的样子——这个撤销是不可恢复的。 用法： 12345git reset &lt;file&gt; # 从缓存区移除特定文件，但不改变工作目录git reset # 重设缓冲区，匹配最近的一次提交，但工作目录不变git reset --hard # 重设缓冲区和工作目录，匹配最近的一次提交git reset &lt;commit&gt; # 将当前分支的末端移到 &lt;commit&gt;，将缓存区重设到这次提交，但不改变工作目录git reset --hard &lt;commit&gt; # 将当前分支的末端移到 &lt;commit&gt;，将缓存区和工作目录都重设到这次提交 git clean将未跟踪的文件从你的工作目录中移除，这一命令是无法撤消的。 git clean 命令经常和 git reset —hard 一起使用。reset 只影响被跟踪的文件，所以还需要一个单独的命令来清理未被跟踪的文件。这个两个命令相结合，你就可以将工作目录回到之前特定提交时的状态。 12345git clean -n # 执行一次 clean 演习。它会告诉你哪些文件在命令执行后会被移除，并非真的删除它git clean -f # 移除当前目录下未被跟踪的文件git clean -f &lt;path&gt; # 移除未跟踪的文件，但限制在某个路径下git clean -df # 移除未跟踪的文件，以及目录git clean -xf # 移除当前目录下未跟踪的文件，以及 Git 一般忽略的文件 保持同步git remotegit remote 命令允许你创建、查看和删除和其它仓库之间的连接。远程连接更像是书签，而不是直接跳转到其他仓库的链接。用法如下： 12345git remote # 列出和其他仓库之间的远程连接git remote -v # 列出和其他仓库之间的远程连接，并同时显示每个连接的 URLgit remote add &lt;name&gt; &lt;url&gt; # 创建一个新的远程仓库连接git remote rm &lt;name&gt; # 移除指定 name 的远程仓库的连接git remote rename &lt;old_name&gt; &lt;new_name&gt; # 将远程连接重命名 git fetchgit fetch 命令将提交从远程仓库导入到你的本地仓库。拉取下来的提交储存为远程分支，而不是我们一直使用的普通的本地分支。用法： 12git fetch &lt;remote&gt; # 拉取仓库中所有的分支，同时会从另一个仓库中下载所有需要的提交和文件git fetch &lt;remote&gt; &lt;branch&gt; # 拉取指定的分支 git pullgit pull 命令用于从另一个存储库或本地分支获取并集成。它的效果和 git fetch 后接 git merge origin/. 一致。用法： 12git pull &lt;remote&gt; # 拉取当前分支对应的远程副本中的更改，并立即并入本地副本git pull --rebase &lt;remote&gt; # 拉取远程分支并与本地分支合并 分支查看分支12345git branch # 查看本地分支git branch -r # 查看远程分支git branch -v # 查看各个分支最后提交的信息git branch --merged # 查看已经被合并到当前分支的分支git branch --no-merged # 查看尚未被合并到当前分支的分支 添加分支12345git checkout &lt;branchname&gt; # 本地创建并切换到某个分支git checkout -b &lt;branchname&gt; # 创建新的分支，并且切换过去git checkout -b &lt;new_br&gt; &lt;branch&gt; # 基于 branch 创建新分支git checkout &lt;commit&gt; # 把某次提交记录 checkout 出来，但无分支信息，切换到其他分支会自动删除git checkout &lt;commit&gt; -b &lt;new_br&gt; # 把某次历史提交记录checkout出来，创建成一个分支 合并分支1234git merge &lt;branchname&gt; # 将某分支合并到当前分支git merge origin/master --no-ff # 不要 Fast-Foward 合并，这样可以生成 merge 提交git rebase master &lt;branch&gt; # 将 master rebase 到branch，相当于：git checkout &lt;branchname&gt; &amp;&amp; git rebase master &amp;&amp; git checkout master &amp;&amp; git merge &lt;branchname&gt; 发布分支123git push &lt;repository&gt; &lt;local_branch&gt; # 创建远程分支，repository 是仓库名git push &lt;repository&gt; &lt;local_branch&gt;:&lt;remote_branch&gt; # 创建远程分支git push &lt;repository&gt; :&lt;remote_branch&gt; # 先删除本地分支，再 push 删除远程分支 删除分支12git branch -d &lt;branchname&gt; # 删除本地某个分支git branch -D &lt;branchname&gt; # 强制删除某个本地分支 (未被合并的分支被删除的时候需要强制) 标签Git 可以在某个时间节点的版本上打上标签，并通常在某版本的最近一次 commit 时标记。 查看标签12git tag # 列出所有可用标签，显示的标签按字母顺序排列git tag -l 'tag condition' # 根据特定的 tag 特征列出符合条件的标签，如 git tag -l 'v1.0.*' 添加标签123git tag &lt;tagname&gt; # 创建轻量标签git tag -a &lt;tagname&gt; -m &quot;tag message&quot; # 创建附注标签git tag -a &lt;tagname&gt; &lt;commit&gt; # 给指定的 commit 补打标签 切换标签1git checkout &lt;tagname&gt; 查看标签信息1git show &lt;tagname&gt; 发布标签12git push origin &lt;tagname&gt; # 将标签提交到 Git 服务器git push origin –tags # 将本地所有标签一次性提交到 Git 服务器 删除标签12git tag -d &lt;tagname&gt; # 删除本地仓库标签git push origin :refs/tags/&lt;tagname&gt; # 删除远程仓库标签","link":"/post/git-workflow-guideline/"},{"title":"浅析 RunLoop","text":"一个线程一次只能执行一个任务，执行完毕后线程就会退出。如果我们需要让线程能随时去处理事件并不退出，通常代码逻辑如下： 12345678int main(int argc, char *argv[]) { while (AppIsRunning) { id whoWakesMe = SleepForWakingUp(); id event = GetEvent(whoWakesMe); HandleEvent(event); } return 0;} 这种模型被成为 Event Loop 。这个机制在许多系统和框架里都有实现，在 OSX/iOS 里，RunLoop 就是这样一种存在。它管理了其需要处理的事件和消息。程序启动时，会启动一个循环。默认处于待命状态，一旦有事件需要处理，就会唤醒 RunLoop 去处理，处理完再次处于休眠状态，等待下一次事件都发生，直到循环结束。 RunLoop 与线程的关系CFRunLoopRef 是在 CoreFoundation 框架内的，它提供了纯 C 函数的 API。NSRunLoop 是基于 CFRunLoopRef 的封装，提供了面向对象的 API，但是这些 API 不是线程安全的。CFRunLoop 是基于 pthread 来管理的。苹果不允许直接创建 RunLoop ，它提供里2个函数：CFRunLoopGetMain() 和 CFRunLoopGetCurrent()。它们内部的源码大致是： 1234567891011121314151617181920212223242526272829303132333435363738/// 全局的Dictionary，key 是 pthread_t， value 是 CFRunLoopRefstatic CFMutableDictionaryRef loopsDic;/// 访问 loopsDic 时的锁static CFSpinLock_t loopsLock;/// 获取一个 pthread 对应的 RunLoop。CFRunLoopRef _CFRunLoopGet(pthread_t thread) { OSSpinLockLock(&amp;loopsLock); if (!loopsDic) { // 第一次进入时，初始化全局Dic，并先为主线程创建一个 RunLoop。 loopsDic = CFDictionaryCreateMutable(); CFRunLoopRef mainLoop = _CFRunLoopCreate(); CFDictionarySetValue(loopsDic, pthread_main_thread_np(), mainLoop); } /// 直接从 Dictionary 里获取。 CFRunLoopRef loop = CFDictionaryGetValue(loopsDic, thread)); if (!loop) { /// 取不到时，创建一个 loop = _CFRunLoopCreate(); CFDictionarySetValue(loopsDic, thread, loop); /// 注册一个回调，当线程销毁时，顺便也销毁其对应的 RunLoop。 _CFSetTSD(..., thread, loop, __CFFinalizeRunLoop); } OSSpinLockUnLock(&amp;loopsLock); return loop;}CFRunLoopRef CFRunLoopGetMain() { return _CFRunLoopGet(pthread_main_thread_np());}CFRunLoopRef CFRunLoopGetCurrent() { return _CFRunLoopGet(pthread_self());} 由上可看出，RunLoop 与 线程之间是一一对应的。它们的关系保存在一个全局的字典里。在除主线程外，一般的线程在创建时 RunLoop 并未创建，如果不主动获取，那么就一直就不会有。总结起来就是 RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时。你只能在一个线程的内部获取其 RunLoop（主线程除外）。 RunLoop 机制一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Source/Timer/Observer。每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，这个 Mode 被称作 CurrentMode。如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer，让其互不影响。上面的解释可以用下面这张图很好的诠释： CFRunLoopSourceRef事件产生的地方。Source有两个版本：Source0 和 Source1。• Source0 只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop，让其处理这个事件。• Source1 包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程，其原理在下面会讲到。 CFRunLoopTimerRef基于时间的触发器，它和 NSTimer 是toll-free bridged 的，可以混用。其包含一个时间长度和一个回调（函数指针）。当其加入到 RunLoop 时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行那个回调。 CFRunLoopObserverRef观察者，每个 Observer 都包含了一个回调（函数指针），当 RunLoop 的状态发生变化时，观察者就能通过回调接受到这个变化。可以观测的时间点有以下几个： 12345678typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) { kCFRunLoopEntry = (1UL &lt;&lt; 0), // 即将进入Loop kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), // 即将处理 Timer kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理 Source kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将进入休眠 kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6), // 刚从休眠中唤醒 kCFRunLoopExit = (1UL &lt;&lt; 7), // 即将退出Loop}; 上面的 Source/Timer/Observer 被统称为 mode item，一个 item 可以被同时加入多个 mode。但一个 item 被重复加入同一个 mode 时是不会有效果的。如果一个 mode 中一个 item 都没有，则 RunLoop 会直接退出，不进入循环。 RunLoop 的 Mode在 RunLoop 中，Mode 常用的分为以下2种： NSDefaultRunLoopModeApp 平时所处的默认状态 UITrackingRunLoopMode追踪 ScrollView 滑动时的状态 *NSRunLoopCommonModes *除了上述2种以外，还存在一个名为 NSRunLoopCommonModes 的伪模式，本质是一组 Mode 的集合，将输入源加入此模式意味着在 Common Modes 中包含的模式都可以处理。 RunLoop 的内部逻辑根据苹果文档里的说明，RunLoop 内部的逻辑大致如下: 内部代码整理如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110/// 用DefaultMode启动void CFRunLoopRun(void) { CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false);}/// 用指定的Mode启动，允许设置RunLoop超时时间int CFRunLoopRunInMode(CFStringRef modeName, CFTimeInterval seconds, Boolean stopAfterHandle) { return CFRunLoopRunSpecific(CFRunLoopGetCurrent(), modeName, seconds, returnAfterSourceHandled);}/// RunLoop的实现int CFRunLoopRunSpecific(runloop, modeName, seconds, stopAfterHandle) { /// 首先根据modeName找到对应mode CFRunLoopModeRef currentMode = __CFRunLoopFindMode(runloop, modeName, false); /// 如果mode里没有source/timer/observer, 直接返回。 if (__CFRunLoopModeIsEmpty(currentMode)) return; /// 1. 通知 Observers: RunLoop 即将进入 loop。 __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopEntry); /// 内部函数，进入loop __CFRunLoopRun(runloop, currentMode, seconds, returnAfterSourceHandled) { Boolean sourceHandledThisLoop = NO; int retVal = 0; do { /// 2. 通知 Observers: RunLoop 即将触发 Timer 回调。 __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeTimers); /// 3. 通知 Observers: RunLoop 即将触发 Source0 (非port) 回调。 __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeSources); /// 执行被加入的block __CFRunLoopDoBlocks(runloop, currentMode); /// 4. RunLoop 触发 Source0 (非port) 回调。 sourceHandledThisLoop = __CFRunLoopDoSources0(runloop, currentMode, stopAfterHandle); /// 执行被加入的block __CFRunLoopDoBlocks(runloop, currentMode); /// 5. 如果有 Source1 (基于port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息。 if (__Source0DidDispatchPortLastTime) { Boolean hasMsg = __CFRunLoopServiceMachPort(dispatchPort, &amp;msg) if (hasMsg) goto handle_msg; } /// 通知 Observers: RunLoop 的线程即将进入休眠(sleep)。 if (!sourceHandledThisLoop) { __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeWaiting); } /// 7. 调用 mach_msg 等待接受 mach_port 的消息。线程将进入休眠, 直到被下面某一个事件唤醒。 /// • 一个基于 port 的Source 的事件。 /// • 一个 Timer 到时间了 /// • RunLoop 自身的超时时间到了 /// • 被其他什么调用者手动唤醒 __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort) { mach_msg(msg, MACH_RCV_MSG, port); // thread wait for receive msg } /// 8. 通知 Observers: RunLoop 的线程刚刚被唤醒了。 __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopAfterWaiting); /// 收到消息，处理消息。 handle_msg: /// 9.1 如果一个 Timer 到时间了，触发这个Timer的回调。 if (msg_is_timer) { __CFRunLoopDoTimers(runloop, currentMode, mach_absolute_time()) } /// 9.2 如果有dispatch到main_queue的block，执行block。 else if (msg_is_dispatch) { __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg); } /// 9.3 如果一个 Source1 (基于port) 发出事件了，处理这个事件 else { CFRunLoopSourceRef source1 = __CFRunLoopModeFindSourceForMachPort(runloop, currentMode, livePort); sourceHandledThisLoop = __CFRunLoopDoSource1(runloop, currentMode, source1, msg); if (sourceHandledThisLoop) { mach_msg(reply, MACH_SEND_MSG, reply); } } /// 执行加入到Loop的block __CFRunLoopDoBlocks(runloop, currentMode); if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) { /// 进入loop时参数说处理完事件就返回。 retVal = kCFRunLoopRunHandledSource; } else if (timeout) { /// 超出传入参数标记的超时时间了 retVal = kCFRunLoopRunTimedOut; } else if (__CFRunLoopIsStopped(runloop)) { /// 被外部调用者强制停止了 retVal = kCFRunLoopRunStopped; } else if (__CFRunLoopModeIsEmpty(runloop, currentMode)) { /// source/timer/observer一个都没有了 retVal = kCFRunLoopRunFinished; } /// 如果没超时，mode里没空，loop也没被停止，那继续loop。 } while (retVal == 0); } /// 10. 通知 Observers: RunLoop 即将退出。 __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);} 由上可知，RunLoop 的内部是一个 do-while 循环。当你调用 CFRunLoopRun() 时，线程就会一直停留在这个循环里。直到超时或被手动停止，该函数才会返回。","link":"/post/runloop/"},{"title":"浅析 Socket","text":"目前网络上大部分应用程序的通信都是 socket 实现的，在解释什么是 socket 之前，要先了解什么是网络进程通信原理。 网络进程通信原理我们知道，在同一台机器上，进程间可以很容易地进行通信。 网络进程通信是不同主机进程间的相互通信，那么只要让一台主机能在网络中定位到另一台主机，并与其建立连接，那么两台主机就能进行通信了。 TCP／IP 协议族已经解决了这个问题，网络层的 IP 地址可以唯一标识网络中的主机，而传输层的“协议+端口”可以唯一标识主机中的应用程序（进程）。利用（ ip 地址，协议，端口）就可以标识网络中另一台主机的进程，网络中的进程通信就是利用这个标识与其它进程进行交互。 socket 起源于 Unix ，而 Unix/Linux 基本哲学之一就是“一切皆文件”，都可以用 1打开 open –&gt; 读写 write/read –&gt; 关闭 close 模式来操作。Socket 是应用层与 TCP/IP 协议族通信的中间软件抽象层，它是一组接口。在设计模式中， Socket 其实就是一个门面模式，它把复杂的 TCP/IP 协议族隐藏在 Socket 接口后面，对用户来说，一组简单的接口就是全部，让 Socket 去组织数据，以符合指定的协议。 具体流程 服务器端先初始化 Socket ，然后与端口绑定 (bind) ，对端口进行监听 (listen) ，调用 accept 阻塞，等待客户端连接。在这时如果有个客户端初始化一个 Socket ，然后连接服务器 (connect) ，如果连接成功，这时客户端与服务器端的连接就建立了。客户端发送数据请求，服务器端接收请求并处理请求，然后把回应数据发送给客户端，客户端读取数据，最后关闭连接，一次交互结束。","link":"/post/socket/"},{"title":"iOS 那些被忽视的数据集合","text":"Foudation 框架中我们常用的数据集合类型有： NSSet 、 NSDictionary 、 NSArray 。实际上苹果在 iOS6 之后也推出过与之一一对应的 NSHashTable 、 NSMapTable 和 NSPointArray ，只不过因为前者功能较为强大，能解决平时开发中遇到的大部分问题，因此更容易被大家所熟知。 NSPointArray在数组中添加一个对象时，会使得对象引用计数器 +1，被数组所持有。如果希望在数据容器中保持对对象弱引用，对象移除时，数组中也随之移除时，该如何处理呢？ 在 iOS6 之前可以调用 NSValue 的 valueWithNonretainedObject 方法去弱化这个对象，然后在加到数据集合中可以达到上述要求。 12NSValue *value = [NSValue valueWithNonretainedObject:obj];NSArray *array = [NSArray arrayWithObject:value]; iOS6 之后可以使用 NSPointArray 来实现对应的要求。 123///初始化方法+ (NSPointerArray *)strongObjectsPointerArray;+ (NSPointerArray *)weakObjectsPointerArray; 使用 strongObjectsPointerArray 之后得到的数组就是等同于 NSMutableArray ，数组对对象的引用是强引用。使用 weakObjectsPointerArray 后得到的数组对对象的持有是弱引用。 因此这样写就能满足刚才的需求： 12NSPointerArray *array = [NSPointerArray weakObjectsPointerArray];[array addPointer:obj]; NSHashTableNSHashTable 是 NSSet / NSMutableSet 的通用版本。 NSSet / NSMutableSet 持有成员的强引用，通过 hash 和 isEqual: 方法来检测成员的散列值和相等性。 NSHashTable 具有下面这些特性： 可变的，没有不可变的对应版本 可以持有成员的弱引用 可以在加入成员时进行 copy 操作 可以存储任意的指针，通过指针来进行相等性和散列检查 NSMapTableNSMapTable 是 NSDictionary 的通用版本。 NSDictionary / NSMutableDictionary 对键进行拷贝，对值持有强引用。 NSMapTable 具有下面这些特性： 可变的，没有不可变的对应版本 可以持有键和值的弱引用，当键或者值当中的一个被释放时，整个这一项就会被移除掉 可以在加入成员时进行 copy 操作 可以存储任意的指针，通过指针来进行相等性和散列检查","link":"/post/the-neglected-data-sets/"},{"title":"基于 CADisplayLink 的 FPS 指示器","text":"CADisplayLinkCADisplayLink 是一个频率和 iOS 设备刷新频率(60HZ)相同的定时器。 重要属性 frameInterval NSInteger 类型的值，用来设置间隔多少帧调用一次 selector 方法，默认值是1，即每帧都调用一次。 duration readOnly 的 CFTimeInterval 值，表示两次屏幕刷新之间的时间间隔。需要注意的是，该属性在 target 的 selector 被首次调用以后才会被赋值。 selector 的调用间隔时间计算方式是：间隔时间 = duration × frameInterval。 使用场景 CADisplayLink 适合做界面的不停重绘。 在屏幕刷新时使用 CADisplayLink 以特定模式注册到 runloop 后，每当屏幕显示内容刷新结束，runloop 就会向 CADisplayLink 指定的 target 发送一次指定的 selector 消息，即它对应的 selector 就会被调用一次。 延迟 iOS设备的屏幕刷新频率是固定的，CADisplayLink 在正常情况下会在每次刷新结束都被调用，精确度相当高。但如果调用的方法比较耗时，超过了屏幕刷新周期，就会导致跳过若干次回调调用机会。 如果 CPU 过于繁忙，无法保证屏幕原有的刷新率，就会导致跳过若干次调用回调方法的机会，跳过次数取决于 CPU 的忙碌程度。 具体实现思路既然 CADisplayLink 可以以屏幕刷新的频率调用指定 selector，而 iOS 系统中正常的屏幕刷新率为60Hz，那么只要在这个方法里面统计指定次数所花的时间，然后通过 1屏幕FPS = 次数 / 时间 就可以得出当前屏幕的刷新频率了。 代码1234567891011121314151617181920212223- (void)setupDisplayLink { //创建CADisplayLink，并添加到当前run loop的NSRunLoopCommonModes _displayLink = [CADisplayLink displayLinkWithTarget:self selector:@selector(linkTicks:)]; [_displayLink addToRunLoop:[NSRunLoop currentRunLoop] forMode:NSRunLoopCommonModes];}- (void)linkTicks:(CADisplayLink *)link { //执行次数 _scheduleTimes ++; //当前时间戳 if(_timestamp == 0){ _timestamp = link.timestamp; } CFTimeInterval timePassed = link.timestamp - _timestamp; if(timePassed &gt;= 1.f){ //fps CGFloat fps = _scheduleTimes/timePassed; NSLog(\"fps:%.1f, timePassed:%f\\n\", fps, timePassed); //reset _timestamp = link.timestamp; _scheduleTimes = 0; }} 具体见 Demo","link":"/post/what-is-cadisplaylink/"},{"title":"基于 runtime 的网络请求封装","text":"近期涉略了一些 runtime 的资料。学以致用，下面介绍如何用 runtime 封装网络请求。 实现原理runtime 有一个方法，可以去遍历一个类对象的所有属性。获取到属性名称以及对应属性的值。 123456789101112MyClass *myClass = [[MyClass alloc] init];//创建了类对象unsigned int outCount = 0;//记录类对象属性的个数Class cls = [myClass class];//获取类名objc_property_t* properties = class_copyPropertyList(cls, &amp;outCount);//获取类的所有对象数组properties outCount表示数组的元素个数for (int i = 0; i &lt; outCount; i++) {//遍历properties数组 objc_property_t property = properties[i];//类对象的每个属性 const char* char_property_name = property_getName(property);//转化成char类型 if (char_property_name) {//判断是否获取成功 NSString *property_name = [[NSString alloc] initWithCString:char_property_name encoding:NSUTF8StringEncoding];// 转换OC类型的字符串 }}free(properties);//释放指针 由此可以得到一个启发：网络请求是可以通过类文件来管理的。 思路所有网络请求的类文件都继承一个基类 BaseNetRequest ，然后在子类的 .h 中写上网络请求中需要的请求参数名，在 BaseNetRequest.m 文件中，通过上述 runtime 的方法获取网络请求参数，并在子类的 init 方法里做统一处理。 优点 网络请求可以通过文件的形式统一管理，方便开发者根据文件结构去寻找对应的请求。 需要做统一操作时，可以在 BaseNetRequest 文件中进行处理。 如何使用项目目录结构 示例代码创建对应的请求类 TestNetRequest ，继承自 BaseNetRequest ，在 .h 中写上对应的请求参数。 调用结果 demo 中有详细的注释和使用方法，地址：NetRequestDemo","link":"/post/struct-net-request-by-runtime/"}],"tags":[{"name":"逆向","slug":"逆向","link":"/tags/%E9%80%86%E5%90%91/"},{"name":"性能优化","slug":"性能优化","link":"/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"调试","slug":"调试","link":"/tags/%E8%B0%83%E8%AF%95/"},{"name":"HTTPS","slug":"HTTPS","link":"/tags/HTTPS/"},{"name":"打包","slug":"打包","link":"/tags/%E6%89%93%E5%8C%85/"},{"name":"workflow","slug":"workflow","link":"/tags/workflow/"},{"name":"RunLoop","slug":"RunLoop","link":"/tags/RunLoop/"},{"name":"Socket","slug":"Socket","link":"/tags/Socket/"},{"name":"Foundation","slug":"Foundation","link":"/tags/Foundation/"},{"name":"计时器","slug":"计时器","link":"/tags/%E8%AE%A1%E6%97%B6%E5%99%A8/"},{"name":"runtime","slug":"runtime","link":"/tags/runtime/"}],"categories":[{"name":"iOS","slug":"iOS","link":"/categories/iOS/"},{"name":"网络","slug":"网络","link":"/categories/%E7%BD%91%E7%BB%9C/"},{"name":"Shell","slug":"Shell","link":"/categories/Shell/"},{"name":"Git","slug":"Git","link":"/categories/Git/"}]}