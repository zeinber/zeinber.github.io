{"pages":[],"posts":[{"title":"iOS 砸壳总结","text":"总结一下关于 iOS 砸壳的几种方式，方便以后查找，不定期更新… dumpdecrypted 原理：让 App 在启动的时候加载动态库 dumpdecrypted.dylib 并执行里面的解密代码，dump 出被加密部分，最后生成一个脱壳的二进制文件 优势：成功率高 劣势：步骤繁琐，解密以后还是一个 .decrypted 结尾的文件，还需要手动转换为可执行文件 推荐指数：🌟 准备步骤 越狱设备 打开 cydia 在搜索中下载安装 OpenSSH、Cycript Mac 电脑 安装 ldid1sudo brew install ldid 使用步骤下载源代码并编译打开 Mac 终端 123$ git clone https://github.com/stefanesser/dumpdecrypted$ cd dumpdecrypted$ make 得到一个动态库 dumpdecrypted.dylib 动态库签名苹果会对非系统的动态库校验签名，因此需要使用 ldid 对 dumpdecrypted.dylib 进行签名 1$ ldid -S dumpdecrypted.dylib 定位待解密的可执行文件请确保越狱设备以及 Mac 保持在同一个网段，将 Mac 终端连接到越狱设备 1$ ssh root@&lt;设备wifiIp地址&gt; 设备默认密码为 alpine 查看进程号和可执行文件路径1$ ps -e 找到 App 可执行文件的进程号和路径并记录下来 获取目标 App 的 Documents 目录附加到指定进程 1$ cycript -p &lt;App进程号&gt; 得到 App 的 Documents 文件夹路径 1$ [[NSFileManager defaultManager] URLsForDirectory:NSDocumentDirectory inDomains:NSUserDomainMask][0] Mac 终端新开一个窗口 1$ scp &lt;dumpdecrypte.dylib 路径&gt; root@&lt;设备 wifiIp 地址&gt;:&lt;App Documents路径&gt; 将 dumpdecrypted.dylib 拷贝到 App 的 Documents 目录 解密ctrl+z 退出 cy 状态，执行砸壳 1$ DYLD_INSERT_LIBRARIES=&lt;dumpdecrypted.dylib路径&gt; &lt;App可执行文件路径&gt; 保存砸壳文件 Mac 终端执行 1$ scp root@&lt;设备wifiIp地址&gt;:&lt;app可执行文件名&gt;.decrypted &lt;Mac端指定路径&gt; 将 App 的 Documents 路径下以 .decrypted 结尾的解密后可执行文件，从越狱设备里拷到电脑上 Clutch 原理：通过 posix_spawnp 创建一个进程，然后暂停进程并 dump 内存，最后生成一个脱壳的二进制文件 优势：相较于 dumpdecrypted 更方便，无需手动注入动态库 劣势：使用 Clutch 解密一些应用会经常失败 推荐指数：🌟🌟🌟 准备步骤 越狱设备 打开 cydia 在搜索中下载安装 OpenSSH Mac 电脑 使用步骤下载源代码并编译推荐使用 Clutch-2.0.4 版本。 1$ git clone --branch 2.0.4 https://github.com/KJCracks/Clutch 方式一：通过 xcodebuild 指令获取 cd 到 clone 下来的 Clutch 目录下，执行： 1$ xcodebuild -project Clutch.xcodeproj -configuration Release ARCHS=&quot;armv7 armv7s arm64&quot; build 生成出来的可执行文件 clutch 就在当前目录下 方式二：通过 Clutch.app 包获取 打开 Clutch.xcodeproj ，编译成功之后，在 Products 目录下找到 Clutch.app，在包内获取 Clutch.app 的可执行文件 clutch 将文件复制到手机中将可执行文件拷贝到手机上: 1scp &lt;可执行文件clutch路径&gt; root@&lt;设备wifIp地址&gt;:/usr/bin/ 解密越狱设备以及 Mac 保持在同一个网段打开 Mac 终端，使用 ssh 连接手机： 12$ ssh root@&lt;设备wifiIp地址&gt;$ clutch -i 终端输出： Installed apps:1: Flashlight &lt;com.bigblueclip.led&gt;2: 微信 &lt;com.tencent.xin&gt;3: QQ同步助手 &lt;com.tencent.QQPim&gt; 根据列表中显示的包名进行砸壳，这里以微信为例 1$ clutch -d com.tencent.xin 可以看到 Clutch 砸壳后的 ipa 文件放到了/private/var/mobile/Documents/Dumped/目录下 保存砸壳文件修改成一个简单的名字，然后拷贝回电脑： 12$ mv /private/var/mobile/Documents/Dumped/com.tencent.xin-iOS8.0-\\(Clutch-2.0.4\\).ipa /private/var/mobile/Documents/Dumped/wechat.ipa$ scp root@&lt;设备wifiIp地址&gt;:/private/var/mobile/Documents/Dumped/wechat.ipa ~/Desktop frida-ios-dump 原理：基于 frida 建立一个双向通信通道，然后在 Mac 端用 python 加载一个 dump.js，在运行应用的时候执行 js 内的解密代码，最后生成一个脱壳的二进制文件 优势：高成功率，便利，自动把砸完壳的 App 传输到 Mac 端 劣势：无 推荐指数：🌟🌟🌟🌟🌟 准备步骤 越狱设备 打开 cydia 添加源：http://build.frida.re 并在搜索中下载安装 frida，安装完成后在 Mac 端执行 frida-ps -U 查看是否能正常执行 Mac 电脑 安装 python1$ brew install python 安装 wget1$ brew install wget 安装 pip12$ wget https://bootstrap.pypa.io/get-pip.py$ sudo python get-pip.py 安装 frida1$ sudo pip install frida –upgrade –ignore-installed six 安装脚本依赖环境1$ sudo pip install -r requirements.txt --upgrade 安装 usbmuxd 与手机通信1$ brew install usbmuxd 使用步骤下载源代码打开 Mac 终端1$ git clone https://github.com/AloneMonkey/frida-ios-dump 修改 dump.py进入 frida-ios-dump 文件夹，打开 dump.py，以下配置是 Mac 端和越狱设备连接的配置，请根据需求进行修改1234User = 'root'Password = 'alpine'Host = 'localhost'Port = 2222 接下来按上述的默认配置进行说明 Mac 连接越狱设备通过 USB 将 Mac 和越狱设备连接，将 22 映射到 Mac 上的 2222 端口，打开 Mac 终端输入 12$ iproxy 2222 22waiting for connection 查看应用列表再开一个终端窗口，输入 1234567$ python dump.py -l PID Name Identifier----- ----------------------- -------------------------------------12317 App Store com.apple.AppStore 4563 信息 com.apple.MobileSMS12251 微信 com.tencent.xin... 解密这里以微信为例，微信的包名为 com.tencent.xin 1$ python dump.py com.tencent.xin 执行完毕，从 dump.py 同级别目录里获取砸完壳的 App","link":"/post/reverse/ios-dumpdecrypt-summary/"},{"title":"iOS 键盘与剪切板的监控方案","text":"键盘与剪切板是用户使用频率最高的两个组件，之前因为业务原因我也调研过这两个组件，本文将要介绍一套对于键盘与剪切板进行监控的方案。 键盘能唤起键盘的方案有几种，我做了如下归类 UITextField、UITextView 原生输入框 WebView 上的 INPUT 和 TEXTAREA 通过 coreText 实现的 TextView，知名的有 YYKit 中的 YYTextView 为了下面方便介绍，将上述3种情况依次简称为情况一、情况二、情况三。 通知对于原生的 UITextField 和 UITextView，可以在 UIKit.framework 下的头文件 UITextField.h 和 UITextView.h 中找到以下2个通知 12// UITextField.hUIKIT_EXTERN NSNotificationName const UITextFieldTextDidChangeNotification; 12// UITextView.hUIKIT_EXTERN NSNotificationName const UITextViewTextDidChangeNotification; 通过监听 UITextFieldTextDidChangeNotification 和 UITextViewTextDidChangeNotification 可以实现对原生 UI 控件输入事件的监控，代码如下： 12345678910/// monitor textField[[NSNotificationCenter defaultCenter] addObserverForName:UITextFieldTextDidChangeNotification object:nil queue:NSOperationQueue.mainQueue usingBlock:^(NSNotification * _Nonnull note) { UITextField *textField = note.object; NSLog(@&quot;[%s] - textField：%@&quot;,__func__,textField.text);}];/// monitor textView[[NSNotificationCenter defaultCenter] addObserverForName:UITextViewTextDidChangeNotification object:nil queue:NSOperationQueue.mainQueue usingBlock:^(NSNotification * _Nonnull note) { UITextView *textView = note.object; NSLog(@&quot;[%s] - textView：%@&quot;,__func__,textView.text);}]; 但是上述的方案只能满足情况一，对于情况二和情况三就显得力不从心了。 响应链既然暴露的 API 没法实现，那就转换一下思路。从原理上分析，用户的点击其实就是一个响应链的过程，因此为了寻找新的解决方案，需要先介绍一下什么是响应链。当一个点击事件产生后，会触发寻找事件接受者和触发事件响应这2个步骤。 寻找事件接受者 当一个触摸亊件生成时，系统会将其加入 UIApplication 的事件队列中。 UIApplication 会取出队列最前面的事件，通过 sendEvent: 方法分发到应用程序的主窗口 window。 主窗口 window 会在当前视图层次结构中找到一个最合适的视图来处理触摸事件，具体流程如下 调用当前视图的 pointInside:withEvent: 方法，判断触摸点是否在当前视图内。 如果返回 NO，那么 hitTest:WithEvent: 就返回 nil。如果返回 YES，就继续遍历子视图，发送 hitTest:withEvent: 消息，直到有视图返回非空对象时返回该对象（或者在全局视图遍历完毕并都返回空对象时返回自身）。 触发事件响应 触发事件将沿着响应者链传递，传递规则如下， 如果当前 view 是另一个 view 的子 view，那么它的父 view 就是下一个响应者。 如果当前 view 是控制器的 view，那么控制器就是下一个响应者。 如果在视图顶层还不能处理事件，那么就传给 window 对象处理。 如果 window 对象也不能处理，则将其传给 UIApplication 对象。 如果 UIApplication 对象也不能处理，就可能传给UIAppDelegate 对象处理。 如果都不能处理，事件将被丢弃。 破局根据响应链流程中提及的公开的 API，可以对以下2个时机进行 hook， 查找响应视图：-[UIView hitTest:WithEvent:]和-[UIView pointInside:WithEvent:] 分发事件对象：-[UIApplication sendEvent:] 查找响应视图这2个是主窗口 window 在当前视图层次结构中找到一个最合适的视图来处理触摸事件的方法，因此对于一次 touch 事件，会被频繁的方法作为监控入口显然是不合适的。 分发事件对象-[UIApplication sendEvent:]是分发事件给 window 的方法，在一个事件发生时只会触发一次，因此比较适合做监控入口。先来看一下该方法的定义 12// UIApplication.h- (void)sendEvent:(UIEvent *)event; 根据响应链的定义，UIApplication 会取出队列最前面的事件，通过 sendEvent: 方法分发到应用程序的主窗口 window。在 UIEvent.h 的头文件里找到了一个 set 集合 - allTouches，定义如下 12// UIEvent.h@property(nonatomic, readonly, nullable) NSSet &lt;UITouch *&gt; *allTouches; 通过以上属性找到的 UITouch 事件就是要找的 touch 对象。由于上述的 sendEvent: 方法会响应所有的事件。因此，需要制定规则筛选出指定的 touch 事件。 筛选 touch 规则列出 UITouch.h 头文件中几个比较重要的属性 1234567891011121314// UITouch.htypedef NS_ENUM(NSInteger, UITouchPhase) { UITouchPhaseBegan, // whenever a finger touches the surface. UITouchPhaseMoved, // whenever a finger moves on the surface. UITouchPhaseStationary, // whenever a finger is touching the surface but hasn't moved since the previous event. UITouchPhaseEnded, // whenever a finger leaves the surface. UITouchPhaseCancelled, // whenever a touch doesn't end but we need to stop tracking (e.g. putting device to face)};// 触摸状态@property(nonatomic,readonly) UITouchPhase phase;// 处理事件的 window@property(nullable,nonatomic,readonly,strong) UIWindow *window;// 能响应触摸事件的 view@property(nullable,nonatomic,readonly,strong) UIView *view; 打印一下点击键盘时 UITouch 对象的属性值，具体如下 123456(lldb) po [touch _ivarDescription]&lt;UITouch: 0x101710650&gt;:in UITouch: _phase (long): 3 _window (UIWindow*): &lt;UIRemoteKeyboardWindow: 0x103908800&gt; _view (UIView*): &lt;UIKeyboardDockView: 0x103a10720&gt; 这里看到 window 为 UIRemoteKeyboardWindow，它是键盘事件响应的 window，因此对于键盘事件可以通过判断 window 是否为 UIRemoteKeyboardWindow 过滤，具体代码如下 12345/// 是否为键盘事件- (BOOL)isKeyboardWithTouch:(UITouch *)touch { // window 为UIRemoteKeyboardWindow，说明touch在键盘上 return [touch.window isKindOfClass:NSClassFromString(@&quot;UIRemoteKeyboardWindow&quot;)];} 剪切板对于剪切板，可以通过 +[UIPasteBoard generalPasteboard] 方法获取到系统的剪切板, 当粘贴事件发生时，粘贴的内容会被写入到 UIPasteboard。手动写入粘贴内容到粘贴板代码如下 1UIPasteboard.generalPasteboard.string = @“粘贴的内容”; 遗憾的是，当用户复制粘贴的时候，并没有调用上述方法，系统应该是通过更底层的 API 实现功能的。重新回到监控剪切板的响应链方案，问题就转换为筛选出剪切板工具栏上的按钮点击事件。 筛选 touch 规则有了之前的经验，这边就直接打印点击工具栏时 touch 的属性值，如下 123456(lldb) po [touch _ivarDescription]&lt;UITouch: 0x1080237d0&gt;:in UITouch: _phase (long): 3 _window (UIWindow*): &lt;UITextEffectsWindow: 0x105300f50&gt; _view (UIView*): &lt;UICalloutBarButton: 0x108025d20&gt; 根据上述信息得出，点击剪切板工具栏的点击事件筛选条件如下。 1234- (BOOL)isClipboardWithTouch:(UITouch *)touch { // view 为UICalloutBarButton且window为UITextEffectsWindow，说明touch在工具栏上 return [touch.view isKindOfClass:NSClassFromString(@&quot;UICalloutBarButton&quot;)] &amp;&amp; [touch.window isKindOfClass:NSClassFromString(@&quot;UITextEffectsWindow&quot;)];} 如果需要确定用户的具体操作，还需要在这基础上在做过滤。用户点击的事件触发在 UICalloutBarButton 上，而 UICalloutBarButton 显然是一个按钮。在 iOS 中，按钮允许 target-action 的方式对其进行监控。通过打印 UICalloutBarButton 的属性值，发现 m_action 去标识具体的方法，方法名刚好就是操作的英文单词，点击 copy 以后结果如下， 123(lldb) po [touch.view _ivarDescription]in UICalloutBarButton: m_action (SEL): paste: 通过判断 m_action 的值即可知道用户再剪切板上进行了什么操作。附剪切板工具栏上的复制、粘贴、剪切的 action 123copy:paste:cut: demo地址demo地址","link":"/post/reverse/ios-user-operation-monitor/"},{"title":"2020年度总结","text":"又是一年落叶黄,一层秋雨一层凉。 关于疫情 年初的疫情，给世界带来了惶恐，大到城市省会，小到街道村子，人人自危。在家的时候，看到隔壁村外地回家过年的一家人刚回家就被抓回去集体隔离的场景，让我不禁开始思考死亡。 记得那么一句话，“你要在众人的簇拥下死去”。我不畏惧死亡，只是希望人生在世，能有一番作为。人最怕的是失去目标，忘记自己的价值。 在每个男孩子的心中，从小都有一个英雄梦。90 后这一代受到太多岛国动漫的影响，总觉得自己是主角吧。我觉得没什么不好，正如上学时经常听到老师口中的那句话，要具有主人翁意识。大到舍身救人做真英雄，小到王者团战里帮残血队友挡一个诸葛亮的大。这个时代，因为之前的某些事，这份意识缺失了。虽然我自己做不到这么伟大，但是也希望以此共勉。希望这个世界，快点好起来。 关于游戏 自己喜欢玩游戏，喜欢在游戏里找到认同感。还记得小时候，在电脑还不普及的年代，在现在看来就是一段 BASIC 堆积的红白机游戏，能让我开心的玩到半夜。后来入坑了王者，简单的操作、快节奏的对局、以及随时随地都能玩等优点，让我很快着迷，以至于满脑子有段时间一直关注这方面的资讯和攻略。 首先，这款游戏一定是一款伟大的游戏，至少手游办联赛、年年皮肤吸金上亿，就已经足够说明它的成功。而且甚至有了 PC 端当年网易的梦幻西游”人人都玩，不完才怪“的味道。 但是在光环下，我也渐渐发现，好多碎片时间被游戏所占用，有时候回到家，第一个念头就是打开游戏来上一把，乐此不疲。以至于之前买的书我都没能好好读完。 “抛开剂量谈危害都是耍流氓”，因此我对它的态度是，减少次数，合理规划时间，适当游戏有益于社交和放松身心，别把自己的人生交给了游戏。 关于苹果 今年的苹果，除了让人期待已久的 5G 系列手机 iPhone12 以外，最惊艳的就是光棍节发布的带有苹果自研芯片 Apple M1 的 Macbook 了。 回想苹果这几年的操作： swift 开源 通用的 swift，后台也能开发 简易的 swiftUI，一套代码3端可用 更快的 M1芯片，app 也能跑在 mac 上不得不承认苹果是一家非常有野心的公司，有当年嬴政一统天下那味了。有人说，iOS 是在 Android 的老路.纵观这几年发布会曝光的内容，确实有那点意思。不过在我看来，这并不是苹果黔驴技穷了。相反，我觉得除了乔布斯之后苹果手机被当成奢侈品卖的那段时间，这几年苹果的发展道路选的还是很正确的。吸取别人有点化为己用，不断垄断每个环节的资源。在安卓生态还是百家争鸣的时候，苹果已经瞧瞧地走在了更前面。大概，也只有强如华为的鸿蒙，才能与之一战了吧。 关于工作我在现在这家公司已经干了快3年了，目前主要做的是 iOS 安全研发，在这之前做过2年的正向 App 开发。平时的工作主要是负责做设备指纹的研发和迭代，当然也负责做一些安全SDK的研发以及一些逆向分析工作。除了开发以外，最令我感到有兴趣的应该是 bug 分析这块。这份工作让我不由想到连载了快25年的《名侦探柯南》里柯南探案的场景。如果说把崩溃比做杀人案，崩溃日志就是现场留下的证据，对应版本的 App 是犯罪现场，用户 则是目击者.作为开发的我就是根据崩溃日志里的信息找出证据，还原崩溃现场，指出导致崩溃真正的元凶，有段时间真的很上头。但是，在一个地方停久了，也会渐渐忘记这个世界是广大的。逆水行舟，不进则退。在大家都在进步的环境下，只有不断地往前走，才能看到更大的世界。 关于自己 性格 我觉得自己的性格这一年比起之前外向了许多。在以前高中刚毕业那会儿，我曾夸张到去饭店叫个服务员都要犹豫半天。我知道自己缺乏自信，不敢去尝试，虽然我讨厌自己这样，但是这也是那个时候最真实的我。乔布斯曾说过，“你的时间有限，所以不要为别人而活“。我作为当事人也最清楚，我是太在意别人的看法，与其说帮别人考虑，倒不如说是给自己的懦弱找借口。如果让一个士兵最快适应战场环境，那就是让他多经历实战。关于如何变的外向这事，没有人能帮你，别人虽然能教给你方法，但是，少年郎，你渴望的力量，其实是来源于你自己啊。所以，勇敢的迈出那一步吧。 “总觉得你一天到晚都很忙，但是却一事无成”，这是之前我的人生导师给我的评价。所以接下来，改掉拖沓、胆怯的坏习惯，立马行动起来，脚踏实地的走好未来的每一步。 身体 “初闻不直达曲中意，再听已是曲中人”。这一年，虽然不想承认，但是头顶确实稀疏了很多，有可能是遗传，也可能是作息不规律的原因。身边的朋友建议我去植发，我拒绝了，我讨厌主动剔成光头。记忆力也渐渐减退，以前学习的时候非常自信，凭着比别人快人一步的优越感，记啥都快，笔记也做得少。因为我觉得记的本子会掉，但是脑子是自己的，只要记住了就不会忘了，没有人能比我更懂我的身体（手动狗头）。但是我现在才发现，自己真的很可笑。好记性不如烂笔头，真正优秀的人是会懂得如何整理自己的所学。正如武侠小说里每一个武功盖世的大侠都会留下一本武功秘籍一样。原来，这才是我和优秀的人之间的差距。我开始学习如何整理，我开始学着如何去静下心来的学习、看书和做笔记。 家庭 这一年，我和长跑七年的女朋友结婚了，婚礼在我老家办的，没有邀请很多人。是她在我要放弃自己的时候，给了我鼓励，给我指明了方向。我真的很幸运能与其相处7年，最后走到了婚姻的殿堂。一辈子很短，万水千山，愿与之同往，愿得一心人，白首不分离。 感觉这一年给家人的时间真的很少，外婆年纪大了，她最大的愿望是在有生之年去外面走走，去见识一下这个世界。说来惭愧，我来杭州已是第4个年头，她心心念念的灵隐寺，我已经拖了几年，都没带她去过。希望疫情稳定之后，我能实现她的愿望。 关于未来 我一直坚信，从小事做起，把细节做好，只有打好基石，大厦才能稳固的道理。在这个什么都能触手可及的时代下，唯有不断地学习才能跟得上时代的节奏。以下是计划表，明年再来回顾写总结的时候，希望未来的自己能不辜负自己现在的期许。 看4本书 （人，要不断地学习啊…） 换一份新的工作，拥抱变化（世界那么大，我想去看看） 业余时间学习至少2门新技能（打工人的吃饭技巧不嫌少） 整理，万事皆可记（做一个有条理的人） 回博客定期清灰，至少输出6篇文章（不行咱b站等级升到6级也行啊） 养成良好的作息，早睡早起（为了我那宝贵的头发） 摇到杭州的车牌，买车（心诚则灵不是嘛，哈哈）","link":"/post/summary/2020-self-summary/"}],"tags":[{"name":"砸壳","slug":"砸壳","link":"/tags/%E7%A0%B8%E5%A3%B3/"},{"name":"响应链","slug":"响应链","link":"/tags/%E5%93%8D%E5%BA%94%E9%93%BE/"},{"name":"总结","slug":"总结","link":"/tags/%E6%80%BB%E7%BB%93/"}],"categories":[{"name":"逆向","slug":"逆向","link":"/categories/%E9%80%86%E5%90%91/"},{"name":"研究","slug":"研究","link":"/categories/%E7%A0%94%E7%A9%B6/"},{"name":"随笔","slug":"随笔","link":"/categories/%E9%9A%8F%E7%AC%94/"}]}