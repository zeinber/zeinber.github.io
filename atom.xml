<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zeinber&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.zeinber.top/"/>
  <updated>2021-01-22T11:28:42.879Z</updated>
  <id>https://blog.zeinber.top/</id>
  
  <author>
    <name>zeinber</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS 键盘与剪切板的监控方案</title>
    <link href="https://blog.zeinber.top/post/design/ios-user-operation-monitor/"/>
    <id>https://blog.zeinber.top/post/design/ios-user-operation-monitor/</id>
    <published>2021-01-04T13:00:00.000Z</published>
    <updated>2021-01-22T11:28:42.879Z</updated>
    
    <content type="html"><![CDATA[<p>键盘与剪切板是用户使用频率最高的两个组件，本文主要探究的是键盘与剪切板的监控方案。</p><a id="more"></a><h2 id="键盘"><a href="#键盘" class="headerlink" title="键盘"></a>键盘</h2><p>能唤起键盘的方案有3种，归类如下</p><ul><li>UITextField、UITextView 原生输入框</li><li>WebView 上的 INPUT 和 TEXTAREA</li><li>非继承重写的 TextView，知名的有 YYKit 中的 YYTextView</li></ul><p>为了下面方便介绍，将上述3种情况依次简称为情况一、情况二、情况三。</p><h3 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h3><p>对于原生的 UITextField 和 UITextView，可以在 UIKit.framework 下的头文件 UITextField.h 和 UITextView.h 中找到以下2个通知</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UITextField.h</span></span><br><span class="line"><span class="built_in">UIKIT_EXTERN</span> <span class="built_in">NSNotificationName</span> <span class="keyword">const</span> <span class="built_in">UITextFieldTextDidChangeNotification</span>;</span><br></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UITextView.h</span></span><br><span class="line"><span class="built_in">UIKIT_EXTERN</span> <span class="built_in">NSNotificationName</span> <span class="keyword">const</span> <span class="built_in">UITextViewTextDidChangeNotification</span>;</span><br></pre></td></tr></table></figure><p>通过监听 UITextFieldTextDidChangeNotification 和 UITextViewTextDidChangeNotification 可以实现对原生 UI 控件输入事件的监控，代码如下</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// monitor textField</span></span><br><span class="line">[[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserverForName:<span class="built_in">UITextFieldTextDidChangeNotification</span> object:<span class="literal">nil</span> queue:<span class="built_in">NSOperationQueue</span>.mainQueue usingBlock:^(<span class="built_in">NSNotification</span> * _Nonnull note) &#123;</span><br><span class="line">    <span class="built_in">UITextField</span> *textField = note.object;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;[%s] - textField：%@&quot;</span>,__func__,textField.text);</span><br><span class="line">&#125;];</span><br><span class="line"><span class="comment">/// monitor textView</span></span><br><span class="line">[[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserverForName:<span class="built_in">UITextViewTextDidChangeNotification</span> object:<span class="literal">nil</span> queue:<span class="built_in">NSOperationQueue</span>.mainQueue usingBlock:^(<span class="built_in">NSNotification</span> * _Nonnull note) &#123;</span><br><span class="line">    <span class="built_in">UITextView</span> *textView = note.object;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;[%s] - textView：%@&quot;</span>,__func__,textView.text);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>但是上述的方案只能满足情况一，对于情况二和情况三就显得力不从心了。<br>因此需要另辟蹊径。重新审视需求，发现三者有一个共同点，就是通过键盘进行输入。<br>因此接下来就从如何监听键盘点击事件入手。</p><h3 id="响应链"><a href="#响应链" class="headerlink" title="响应链"></a>响应链</h3><p>从原理上分析，用户的点击其实就是一个响应链的过程，因此为了寻找新的解决方案，需要先介绍一下什么是响应链。<br>当一个点击事件产生后，会触发寻找事件接受者和触发事件响应这2个步骤。</p><h4 id="寻找事件接受者"><a href="#寻找事件接受者" class="headerlink" title="寻找事件接受者"></a>寻找事件接受者</h4><ul><li>当一个触摸亊件生成时，系统会将其加入 UIApplication 的事件队列中。</li><li>UIApplication 会取出队列最前面的事件，通过 sendEvent: 方法分发到应用程序的主窗口 window。</li><li>主窗口 window 会在当前视图层次结构中找到一个最合适的视图来处理触摸事件，具体流程如下<ul><li>调用当前视图的 pointInside:withEvent: 方法，判断触摸点是否在当前视图内。</li><li>如果返回 NO，那么 hitTest:WithEvent: 就返回 nil。如果返回 YES，就继续遍历子视图，发送 hitTest:withEvent: 消息，直到有视图返回非空对象时返回该对象（或者在全局视图遍历完毕并都返回空对象时返回自身）。</li></ul></li></ul><h4 id="触发事件响应"><a href="#触发事件响应" class="headerlink" title="触发事件响应"></a>触发事件响应</h4><ul><li>触发事件将沿着响应者链传递，传递规则如下，<ul><li>如果当前 view 是另一个 view 的子 view，那么它的父 view 就是下一个响应者。</li><li>如果当前 view 是控制器的 view，那么控制器就是下一个响应者。</li><li>如果在视图顶层还不能处理事件，那么就传给 window 对象处理。</li><li>如果 window 对象也不能处理，则将其传给 UIApplication 对象。</li><li>如果 UIApplication 对象也不能处理，就可能传给 UIAppDelegate 对象处理。</li><li>如果都不能处理，事件将被丢弃。</li></ul></li></ul><h3 id="破局"><a href="#破局" class="headerlink" title="破局"></a>破局</h3><p>根据响应链流程中提及的公开的 API，可以对以下2个时机进行 hook，</p><ul><li>查找响应视图：<code>-[UIView hitTest:WithEvent:]</code>和<code>-[UIView pointInside:WithEvent:]</code></li><li>分发事件对象：<code>-[UIApplication sendEvent:]</code></li></ul><h4 id="查找响应视图"><a href="#查找响应视图" class="headerlink" title="查找响应视图"></a>查找响应视图</h4><p>这2个是主窗口 window 在当前视图层次结构中找到一个最合适的视图来处理触摸事件的方法，因此对于一次 touch 事件，会被频繁调用的方法作为监控入口显然是不合适的。</p><h4 id="分发事件对象"><a href="#分发事件对象" class="headerlink" title="分发事件对象"></a>分发事件对象</h4><p>-[UIApplication sendEvent:] 是分发事件给 window 的方法，在一个事件发生时只会触发一次，因此比较适合做监控入口。<br>先来看一下该方法的定义</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UIApplication.h</span></span><br><span class="line">- (<span class="keyword">void</span>)sendEvent:(<span class="built_in">UIEvent</span> *)event;</span><br></pre></td></tr></table></figure><p>根据响应链的定义，UIApplication 会取出队列最前面的事件，通过 sendEvent: 方法分发到应用程序的主窗口 window。<br>在 UIEvent.h 的头文件里找到了一个 set 集合 - allTouches，定义如下</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UIEvent.h</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">nullable</span>) <span class="built_in">NSSet</span> &lt;<span class="built_in">UITouch</span> *&gt; *allTouches;</span><br></pre></td></tr></table></figure><p>通过以上属性找到的 UITouch 事件就是要找的 touch 对象。<br>由于上述的 sendEvent: 方法会响应所有的事件。因此，需要制定规则筛选出指定的 touch 事件。</p><h4 id="筛选-touch-规则"><a href="#筛选-touch-规则" class="headerlink" title="筛选 touch 规则"></a>筛选 touch 规则</h4><p>列出 UITouch.h 头文件中几个比较重要的属性</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UITouch.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, <span class="built_in">UITouchPhase</span>) &#123;</span><br><span class="line">    <span class="built_in">UITouchPhaseBegan</span>,             <span class="comment">// whenever a finger touches the surface.</span></span><br><span class="line">    <span class="built_in">UITouchPhaseMoved</span>,             <span class="comment">// whenever a finger moves on the surface.</span></span><br><span class="line">    <span class="built_in">UITouchPhaseStationary</span>,        <span class="comment">// whenever a finger is touching the surface but hasn&#x27;t moved since the previous event.</span></span><br><span class="line">    <span class="built_in">UITouchPhaseEnded</span>,             <span class="comment">// whenever a finger leaves the surface.</span></span><br><span class="line">    <span class="built_in">UITouchPhaseCancelled</span>,         <span class="comment">// whenever a touch doesn&#x27;t end but we need to stop tracking (e.g. putting device to face)</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 触摸状态</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>) <span class="built_in">UITouchPhase</span>        phase;</span><br><span class="line"><span class="comment">// 处理事件的 window</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>,<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>,<span class="keyword">strong</span>) <span class="built_in">UIWindow</span>                        *window;</span><br><span class="line"><span class="comment">// 能响应触摸事件的 view</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>,<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>,<span class="keyword">strong</span>) <span class="built_in">UIView</span>                          *view;</span><br></pre></td></tr></table></figure><p>打印一下点击键盘时 UITouch 对象的属性值，</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po [touch _ivarDescription]</span><br><span class="line">&lt;<span class="built_in">UITouch</span>: <span class="number">0x101710650</span>&gt;:</span><br><span class="line"><span class="keyword">in</span> <span class="built_in">UITouch</span>:</span><br><span class="line">_phase (<span class="keyword">long</span>): <span class="number">3</span></span><br><span class="line">_window (<span class="built_in">UIWindow</span>*): &lt;<span class="built_in">UIRemoteKeyboardWindow</span>: <span class="number">0x103908800</span>&gt;</span><br><span class="line">_view (<span class="built_in">UIView</span>*): &lt;<span class="built_in">UIKeyboardDockView</span>: <span class="number">0x103a10720</span>&gt;</span><br></pre></td></tr></table></figure><p>这里看到 window 为 UIRemoteKeyboardWindow，它是键盘事件响应的 window，因此对于键盘事件可以通过判断 window 是否为 UIRemoteKeyboardWindow 进行过滤</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 是否为键盘事件</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)isKeyboardWithTouch:(<span class="built_in">UITouch</span> *)touch &#123;</span><br><span class="line">    <span class="comment">// window 为UIRemoteKeyboardWindow，说明touch在键盘上</span></span><br><span class="line">    <span class="keyword">return</span> [touch.window isKindOfClass:<span class="built_in">NSClassFromString</span>(<span class="string">@&quot;UIRemoteKeyboardWindow&quot;</span>)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="剪切板"><a href="#剪切板" class="headerlink" title="剪切板"></a>剪切板</h2><p>对于剪切板，可以通过 +[UIPasteBoard generalPasteboard] 方法获取到系统的剪切板对象，当粘贴事件发生时，粘贴的内容会被写入到 UIPasteboard。手动写入粘贴内容到粘贴板代码如下</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIPasteboard</span>.generalPasteboard.string = @“粘贴的内容”;</span><br></pre></td></tr></table></figure><p>遗憾的是，当用户复制粘贴的时候，并没有调用上述方法，系统应该是通过更底层的 API 实现功能的。<br>重新回到监控剪切板的响应链方案，问题就转换为从众多的 touch 事件中筛选出剪切板工具栏上的按钮点击事件。</p><h3 id="筛选-touch-规则-1"><a href="#筛选-touch-规则-1" class="headerlink" title="筛选 touch 规则"></a>筛选 touch 规则</h3><p>有了之前的经验，我直接打印点击工具栏时 touch 的属性值</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po [touch _ivarDescription]</span><br><span class="line">&lt;<span class="built_in">UITouch</span>: <span class="number">0x1080237d0</span>&gt;:</span><br><span class="line"><span class="keyword">in</span> <span class="built_in">UITouch</span>:</span><br><span class="line">_phase (<span class="keyword">long</span>): <span class="number">3</span></span><br><span class="line">_window (<span class="built_in">UIWindow</span>*): &lt;<span class="built_in">UITextEffectsWindow</span>: <span class="number">0x105300f50</span>&gt;</span><br><span class="line">_view (<span class="built_in">UIView</span>*): &lt;<span class="built_in">UICalloutBarButton</span>: <span class="number">0x108025d20</span>&gt;</span><br></pre></td></tr></table></figure><p>根据上述信息得出，点击剪切板工具栏的点击事件筛选条件如下</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)isClipboardWithTouch:(<span class="built_in">UITouch</span> *)touch &#123;</span><br><span class="line">    <span class="comment">// view 为UICalloutBarButton且window为UITextEffectsWindow，说明touch在工具栏上</span></span><br><span class="line">    <span class="keyword">return</span> [touch.view isKindOfClass:<span class="built_in">NSClassFromString</span>(<span class="string">@&quot;UICalloutBarButton&quot;</span>)] &amp;&amp; [touch.window isKindOfClass:<span class="built_in">NSClassFromString</span>(<span class="string">@&quot;UITextEffectsWindow&quot;</span>)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要确定用户的具体操作，还需要在这基础上在做过滤。<br>用户点击的事件触发在 UICalloutBarButton 上，而 UICalloutBarButton 显然是一个按钮。在 iOS 中，按钮允许 target-action 的方式对其进行监控。<br>点击剪切板上的 Copy 并打印 UICalloutBarButton 的属性值，发现 m_action 的结果如下，</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po [touch.view _ivarDescription]</span><br><span class="line"><span class="keyword">in</span> <span class="built_in">UICalloutBarButton</span>:</span><br><span class="line">m_action (SEL): paste:</span><br></pre></td></tr></table></figure><p>通过判断 m_action 的值即可知道用户在剪切板上的具体操作。<br>附剪切板工具栏上的复制、粘贴、剪切的 m_action 值。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">copy</span>:</span><br><span class="line">paste:</span><br><span class="line">cut:</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>经过上述的探究以及分析，已经可以实现对键盘与剪切板的监控。<br>方案大致如下，</p><ul><li>通过 hook 分发事件方法 -[UIApplication sendEvent:] 找到点击事件的时机</li><li>根据键盘和剪切板点击时的特征制定筛选条件</li><li>对响应事件进行处理，回调<br>demo 的完整代码已经上传到 GitHub。<br>附上<a href="https://github.com/zeinber/ZBUserOperationMonitor">demo地址</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;键盘与剪切板是用户使用频率最高的两个组件，本文主要探究的是键盘与剪切板的监控方案。&lt;/p&gt;
    
    </summary>
    
    
      <category term="研究" scheme="https://blog.zeinber.top/categories/%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="响应链" scheme="https://blog.zeinber.top/tags/%E5%93%8D%E5%BA%94%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>2020年度总结</title>
    <link href="https://blog.zeinber.top/post/summary/2020-self-summary/"/>
    <id>https://blog.zeinber.top/post/summary/2020-self-summary/</id>
    <published>2020-12-04T07:43:11.000Z</published>
    <updated>2021-01-22T11:36:54.940Z</updated>
    
    <content type="html"><![CDATA[<p>  又是一年落叶黄,一层秋雨一层凉。</p>  <a id="more"></a><p><img src="autumn.jpg" alt=""></p><h2 id="关于疫情"><a href="#关于疫情" class="headerlink" title="关于疫情"></a>关于疫情</h2><p>  年初的疫情，给世界带来了惶恐，大到城市省会，小到街道村子，人人自危。在家的时候，看到隔壁村外地回家过年的一家人刚回家就被抓回去集体隔离的场景，让我不禁开始思考死亡。<br>  记得那么一句话，“你要在众人的簇拥下死去”。我不畏惧死亡，只是希望人生在世，能有一番作为。人最怕的是失去目标，忘记自己的价值。<br>  在每个男孩子的心中，从小都有一个英雄梦。90 后这一代受到太多岛国动漫的影响，总觉得自己是主角吧。我觉得没什么不好，正如上学时经常听到老师口中的那句话，要具有主人翁意识。大到舍身救人做真英雄，小到王者团战里帮残血队友挡一个诸葛亮的大。这个时代，因为之前的某些事，这份意识缺失了。虽然我自己做不到这么伟大，但是也希望以此共勉。希望这个世界，快点好起来。</p><h2 id="关于游戏"><a href="#关于游戏" class="headerlink" title="关于游戏"></a>关于游戏</h2><p>  自己喜欢玩游戏，喜欢在游戏里找到认同感。还记得小时候，在电脑还不普及的年代，在现在看来就是一段 <code>BASIC</code> 堆积的红白机游戏，能让我开心的玩到半夜。后来入坑了王者，简单的操作、快节奏的对局、以及随时随地都能玩等优点，让我很快着迷，以至于满脑子有段时间一直关注这方面的资讯和攻略。<br>  首先，这款游戏一定是一款伟大的游戏，至少手游办联赛、年年皮肤吸金上亿，就已经足够说明它的成功。而且甚至有了 <code>PC</code> 端当年网易的梦幻西游”人人都玩，不完才怪“的味道。<br>  但是在光环下，我也渐渐发现，好多碎片时间被游戏所占用，有时候回到家，第一个念头就是打开游戏来上一把，乐此不疲。以至于之前买的书我都没能好好读完。<br>  “抛开剂量谈危害都是耍流氓”，因此我对它的态度是，减少次数，合理规划时间，适当游戏有益于社交和放松身心，别把自己的人生交给了游戏。</p><h2 id="关于苹果"><a href="#关于苹果" class="headerlink" title="关于苹果"></a>关于苹果</h2><p>  今年的苹果，除了让人期待已久的 <code>5G</code> 系列手机 <code>iPhone12</code> 以外，最惊艳的就是光棍节发布的带有苹果自研芯片 <code>Apple M1</code> 的 <code>Macbook</code> 了。<br>  回想苹果这几年的操作：</p><ul><li><p><code>swift</code> 开源</p></li><li><p>通用的 <code>swift</code>，后台也能开发</p></li><li><p>简易的 <code>swiftUI</code>，一套代码3端可用</p></li><li><p>更快的 <code>M1</code>芯片，<code>app</code> 也能跑在 mac 上<br>不得不承认苹果是一家非常有野心的公司，有当年嬴政一统天下那味了。<br>有人说，<code>iOS</code> 是在 <code>Android</code> 的老路.纵观这几年发布会曝光的内容，确实有那点意思。不过在我看来，这并不是苹果黔驴技穷了。<br>相反，我觉得除了乔布斯之后苹果手机被当成奢侈品卖的那段时间，这几年苹果的发展道路选的还是很正确的。吸取别人有点化为己用，不断垄断每个环节的资源。在安卓生态还是百家争鸣的时候，苹果已经瞧瞧地走在了更前面。大概，也只有强如华为的鸿蒙，才能与之一战了吧。</p><h2 id="关于工作"><a href="#关于工作" class="headerlink" title="关于工作"></a>关于工作</h2><p>我在现在这家公司已经干了快3年了，目前主要做的是 <code>iOS</code> 安全研发，在这之前做过2年的正向 <code>App</code> 开发。平时的工作主要是负责做设备指纹的研发和迭代，当然也负责做一些安全SDK的研发以及一些逆向分析工作。<br>除了开发以外，最令我感到有兴趣的应该是 <code>bug</code> 分析这块。这份工作让我不由想到连载了快25年的《名侦探柯南》里柯南探案的场景。<br>如果说把崩溃比做杀人案，崩溃日志就是现场留下的证据，对应版本的 <code>App</code> 是犯罪现场，<code>用户</code> 则是目击者.作为开发的我就是根据崩溃日志里的信息找出证据，还原崩溃现场，指出导致崩溃真正的元凶，有段时间真的很上头。<br>但是，在一个地方停久了，也会渐渐忘记这个世界是广大的。逆水行舟，不进则退。在大家都在进步的环境下，只有不断地往前走，才能看到更大的世界。</p><h2 id="关于自己"><a href="#关于自己" class="headerlink" title="关于自己"></a>关于自己</h2></li><li><p>性格</p><ul><li>我觉得自己的性格这一年比起之前外向了许多。在以前高中刚毕业那会儿，我曾夸张到去饭店叫个服务员都要犹豫半天。我知道自己缺乏自信，不敢去尝试，虽然我讨厌自己这样，但是这也是那个时候最真实的我。乔布斯曾说过，“你的时间有限，所以不要为别人而活“。我作为当事人也最清楚，我是太在意别人的看法，与其说帮别人考虑，倒不如说是给自己的懦弱找借口。如果让一个士兵最快适应战场环境，那就是让他多经历实战。关于如何变的外向这事，没有人能帮你，别人虽然能教给你方法，但是，少年郎，你渴望的力量，其实是来源于你自己啊。所以，勇敢的迈出那一步吧。</li><li>“总觉得你一天到晚都很忙，但是却一事无成”，这是之前我的人生导师给我的评价。所以接下来，改掉拖沓、胆怯的坏习惯，立马行动起来，脚踏实地的走好未来的每一步。</li></ul></li><li><p>身体</p><ul><li>“初闻不直达曲中意，再听已是曲中人”。这一年，虽然不想承认，但是头顶确实稀疏了很多，有可能是遗传，也可能是作息不规律的原因。身边的朋友建议我去植发，我拒绝了，我讨厌主动剔成光头。记忆力也渐渐减退，以前学习的时候非常自信，凭着比别人快人一步的优越感，记啥都快，笔记也做得少。因为我觉得记的本子会掉，但是脑子是自己的，只要记住了就不会忘了，没有人能比我更懂我的身体（手动狗头）。但是我现在才发现，自己真的很可笑。好记性不如烂笔头，真正优秀的人是会懂得如何整理自己的所学。正如武侠小说里每一个武功盖世的大侠都会留下一本武功秘籍一样。原来，这才是我和优秀的人之间的差距。我开始学习如何整理，我开始学着如何去静下心来的学习、看书和做笔记。</li></ul></li><li><p>家庭</p><ul><li>这一年，我和长跑七年的女朋友结婚了，婚礼在我老家办的，没有邀请很多人。是她在我要放弃自己的时候，给了我鼓励，给我指明了方向。我真的很幸运能与其相处7年，最后走到了婚姻的殿堂。一辈子很短，万水千山，愿与之同往，愿得一心人，白首不分离。</li><li>感觉这一年给家人的时间真的很少，外婆年纪大了，她最大的愿望是在有生之年去外面走走，去见识一下这个世界。说来惭愧，我来杭州已是第4个年头，她心心念念的灵隐寺，我已经拖了几年，都没带她去过。希望疫情稳定之后，我能实现她的愿望。</li></ul></li></ul><h2 id="关于未来"><a href="#关于未来" class="headerlink" title="关于未来"></a>关于未来</h2><p>  我一直坚信，从小事做起，把细节做好，只有打好基石，大厦才能稳固的道理。在这个什么都能触手可及的时代下，唯有不断地学习才能跟得上时代的节奏。以下是计划表，明年再来回顾写总结的时候，希望未来的自己能不辜负自己现在的期许。</p><ul><li>看4本书 （人，要不断地学习啊…）</li><li>换一份新的工作，拥抱变化（世界那么大，我想去看看）</li><li>业余时间学习至少2门新技能（打工人的吃饭技巧不嫌少）</li><li>整理，万事皆可记（做一个有条理的人）</li><li>回博客定期清灰，至少输出6篇文章（不行咱b站等级升到6级也行啊）</li><li>养成良好的作息，早睡早起（为了我那宝贵的头发）</li><li>摇到杭州的车牌，买车（心诚则灵不是嘛，哈哈）</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  又是一年落叶黄,一层秋雨一层凉。&lt;/p&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="https://blog.zeinber.top/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="总结" scheme="https://blog.zeinber.top/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>iOS 砸壳总结</title>
    <link href="https://blog.zeinber.top/post/reverse/ios-dumpdecrypt-summary/"/>
    <id>https://blog.zeinber.top/post/reverse/ios-dumpdecrypt-summary/</id>
    <published>2017-11-08T07:43:11.000Z</published>
    <updated>2021-01-07T09:18:38.053Z</updated>
    
    <content type="html"><![CDATA[<p>总结一下关于 iOS 砸壳的几种方式，方便以后查找，不定期更新…</p><a id="more"></a><h2 id="dumpdecrypted"><a href="#dumpdecrypted" class="headerlink" title="dumpdecrypted"></a><a href="https://github.com/stefanesser/dumpdecrypted">dumpdecrypted</a></h2><ul><li>原理：让 App 在启动的时候加载动态库 dumpdecrypted.dylib 并执行里面的解密代码，dump 出被加密部分，最后生成一个脱壳的二进制文件</li><li>优势：成功率高</li><li>劣势：步骤繁琐，解密以后还是一个 .decrypted 结尾的文件，还需要手动转换为可执行文件</li><li>推荐指数：🌟</li></ul><h3 id="准备步骤"><a href="#准备步骤" class="headerlink" title="准备步骤"></a>准备步骤</h3><ul><li>越狱设备<ul><li>打开 cydia 在搜索中下载安装 OpenSSH、Cycript</li></ul></li><li>Mac 电脑<ul><li>安装 ldid<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo brew install ldid</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><h4 id="下载源代码并编译"><a href="#下载源代码并编译" class="headerlink" title="下载源代码并编译"></a>下载源代码并编译</h4><p>打开 Mac 终端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https:&#x2F;&#x2F;github.com&#x2F;stefanesser&#x2F;dumpdecrypted</span><br><span class="line">$ cd dumpdecrypted</span><br><span class="line">$ make</span><br></pre></td></tr></table></figure><p>得到一个动态库 dumpdecrypted.dylib</p><h4 id="动态库签名"><a href="#动态库签名" class="headerlink" title="动态库签名"></a>动态库签名</h4><p>苹果会对非系统的动态库校验签名，因此需要使用 ldid 对 dumpdecrypted.dylib 进行签名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ldid -S dumpdecrypted.dylib</span><br></pre></td></tr></table></figure><h4 id="定位待解密的可执行文件"><a href="#定位待解密的可执行文件" class="headerlink" title="定位待解密的可执行文件"></a>定位待解密的可执行文件</h4><p>请确保越狱设备以及 Mac 保持在同一个网段，<br>将 Mac 终端连接到越狱设备</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh root@&lt;设备wifiIp地址&gt;</span><br></pre></td></tr></table></figure><p>设备默认密码为 alpine</p><h4 id="查看进程号和可执行文件路径"><a href="#查看进程号和可执行文件路径" class="headerlink" title="查看进程号和可执行文件路径"></a>查看进程号和可执行文件路径</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ps -e</span><br></pre></td></tr></table></figure><p>找到 App 可执行文件的进程号和路径并记录下来</p><h4 id="获取目标-App-的-Documents-目录"><a href="#获取目标-App-的-Documents-目录" class="headerlink" title="获取目标 App 的 Documents 目录"></a>获取目标 App 的 Documents 目录</h4><p>附加到指定进程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cycript -p &lt;App进程号&gt;</span><br></pre></td></tr></table></figure><p> 得到 App 的 Documents 文件夹路径<br>  <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ [[<span class="built_in">NSFileManager</span> defaultManager] URLsForDirectory:<span class="built_in">NSDocumentDirectory</span> inDomains:<span class="built_in">NSUserDomainMask</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure></p><p>Mac 终端新开一个窗口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ scp &lt;dumpdecrypte.dylib 路径&gt; root@&lt;设备 wifiIp 地址&gt;:&lt;App Documents路径&gt; </span><br></pre></td></tr></table></figure><p>将 dumpdecrypted.dylib 拷贝到 App 的 Documents 目录</p><h4 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h4><p>ctrl+z 退出 cy 状态，执行砸壳</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ DYLD_INSERT_LIBRARIES=&lt;dumpdecrypted.dylib路径&gt; &lt;App可执行文件路径&gt;</span><br></pre></td></tr></table></figure><h4 id="保存砸壳文件"><a href="#保存砸壳文件" class="headerlink" title="保存砸壳文件"></a>保存砸壳文件</h4><p> Mac 终端执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ scp root@&lt;设备wifiIp地址&gt;:&lt;app可执行文件名&gt;.decrypted &lt;Mac端指定路径&gt;</span><br></pre></td></tr></table></figure><p>将 App 的 Documents 路径下以 .decrypted 结尾的解密后可执行文件，从越狱设备里拷到电脑上</p><h2 id="Clutch"><a href="#Clutch" class="headerlink" title="Clutch"></a><a href="https://github.com/KJCracks/Clutch">Clutch</a></h2><ul><li>原理：通过 posix_spawnp 创建一个进程，然后暂停进程并 dump 内存，最后生成一个脱壳的二进制文件</li><li>优势：相较于 dumpdecrypted 更方便，无需手动注入动态库</li><li>劣势：使用 Clutch 解密一些应用会经常失败</li><li>推荐指数：🌟🌟🌟</li></ul><h3 id="准备步骤-1"><a href="#准备步骤-1" class="headerlink" title="准备步骤"></a>准备步骤</h3><ul><li>越狱设备<ul><li>打开 cydia 在搜索中下载安装 OpenSSH</li></ul></li><li>Mac 电脑</li></ul><h3 id="使用步骤-1"><a href="#使用步骤-1" class="headerlink" title="使用步骤"></a>使用步骤</h3><h4 id="下载源代码并编译-1"><a href="#下载源代码并编译-1" class="headerlink" title="下载源代码并编译"></a>下载源代码并编译</h4><p>推荐使用 Clutch-2.0.4 版本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone --branch 2.0.4 https:&#x2F;&#x2F;github.com&#x2F;KJCracks&#x2F;Clutch</span><br></pre></td></tr></table></figure><p><strong>方式一：通过 xcodebuild 指令获取</strong></p><p>cd 到 clone 下来的 Clutch 目录下，执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ xcodebuild -project Clutch.xcodeproj -configuration Release ARCHS&#x3D;&quot;armv7 armv7s arm64&quot; build</span><br></pre></td></tr></table></figure><p>生成出来的可执行文件 clutch 就在当前目录下</p><p><strong>方式二：通过 Clutch.app 包获取</strong></p><p>打开 Clutch.xcodeproj ，编译成功之后，在 Products 目录下找到 Clutch.app，在包内获取 Clutch.app 的可执行文件 clutch</p><h4 id="将文件复制到手机中"><a href="#将文件复制到手机中" class="headerlink" title="将文件复制到手机中"></a>将文件复制到手机中</h4><p>将可执行文件拷贝到手机上:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp &lt;可执行文件clutch路径&gt; root@&lt;设备wifIp地址&gt;:&#x2F;usr&#x2F;bin&#x2F;</span><br></pre></td></tr></table></figure><h4 id="解密-1"><a href="#解密-1" class="headerlink" title="解密"></a>解密</h4><p>越狱设备以及 Mac 保持在同一个网段<br>打开 Mac 终端，使用 ssh 连接手机：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ssh root@&lt;设备wifiIp地址&gt;</span><br><span class="line">$ clutch -i</span><br></pre></td></tr></table></figure><p>终端输出：</p><blockquote><p>Installed apps:<br>1:   Flashlight &lt;com.bigblueclip.led&gt;<br>2:   微信 &lt;com.tencent.xin&gt;<br>3:   QQ同步助手 &lt;com.tencent.QQPim&gt;</p></blockquote><p>根据列表中显示的包名进行砸壳，这里以微信为例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ clutch -d com.tencent.xin</span><br></pre></td></tr></table></figure><p>可以看到 Clutch 砸壳后的 ipa 文件放到了<code>/private/var/mobile/Documents/Dumped/</code>目录下</p><h4 id="保存砸壳文件-1"><a href="#保存砸壳文件-1" class="headerlink" title="保存砸壳文件"></a>保存砸壳文件</h4><p>修改成一个简单的名字，然后拷贝回电脑：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mv &#x2F;private&#x2F;var&#x2F;mobile&#x2F;Documents&#x2F;Dumped&#x2F;com.tencent.xin-iOS8.0-\(Clutch-2.0.4\).ipa &#x2F;private&#x2F;var&#x2F;mobile&#x2F;Documents&#x2F;Dumped&#x2F;wechat.ipa</span><br><span class="line">$ scp root@&lt;设备wifiIp地址&gt;:&#x2F;private&#x2F;var&#x2F;mobile&#x2F;Documents&#x2F;Dumped&#x2F;wechat.ipa ~&#x2F;Desktop</span><br></pre></td></tr></table></figure><h2 id="frida-ios-dump"><a href="#frida-ios-dump" class="headerlink" title="frida-ios-dump"></a><a href="https://github.com/AloneMonkey/frida-ios-dump">frida-ios-dump</a></h2><ul><li>原理：基于 frida 建立一个双向通信通道，然后在 Mac 端用 python 加载一个 dump.js，在运行应用的时候执行 js 内的解密代码，最后生成一个脱壳的二进制文件</li><li>优势：高成功率，便利，自动把砸完壳的 App 传输到 Mac 端</li><li>劣势：无</li><li>推荐指数：🌟🌟🌟🌟🌟</li></ul><h3 id="准备步骤-2"><a href="#准备步骤-2" class="headerlink" title="准备步骤"></a>准备步骤</h3><ul><li>越狱设备<ul><li>打开 cydia 添加源：<a href="http://build.frida.re">http://build.frida.re</a> 并在搜索中下载安装 frida，安装完成后在 Mac 端执行 frida-ps -U 查看是否能正常执行</li></ul></li><li>Mac 电脑<ul><li>安装 python<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install python</span><br></pre></td></tr></table></figure></li><li>安装 wget<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install wget</span><br></pre></td></tr></table></figure></li><li>安装 pip<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ wget https:&#x2F;&#x2F;bootstrap.pypa.io&#x2F;get-pip.py</span><br><span class="line">$ sudo python get-pip.py</span><br></pre></td></tr></table></figure></li><li>安装 frida<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pip install frida –upgrade –ignore-installed six</span><br></pre></td></tr></table></figure></li><li>安装脚本依赖环境<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pip install -r requirements.txt --upgrade</span><br></pre></td></tr></table></figure></li><li>安装 usbmuxd 与手机通信<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install usbmuxd</span><br></pre></td></tr></table></figure><h3 id="使用步骤-2"><a href="#使用步骤-2" class="headerlink" title="使用步骤"></a>使用步骤</h3><h4 id="下载源代码"><a href="#下载源代码" class="headerlink" title="下载源代码"></a>下载源代码</h4>打开 Mac 终端<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https:&#x2F;&#x2F;github.com&#x2F;AloneMonkey&#x2F;frida-ios-dump</span><br></pre></td></tr></table></figure><h4 id="修改-dump-py"><a href="#修改-dump-py" class="headerlink" title="修改 dump.py"></a>修改 dump.py</h4>进入 frida-ios-dump 文件夹，打开 dump.py，以下配置是 Mac 端和越狱设备连接的配置，请根据需求进行修改<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">User &#x3D; &#39;root&#39;</span><br><span class="line">Password &#x3D; &#39;alpine&#39;</span><br><span class="line">Host &#x3D; &#39;localhost&#39;</span><br><span class="line">Port &#x3D; 2222</span><br></pre></td></tr></table></figure>接下来按上述的默认配置进行说明</li></ul></li></ul><h4 id="Mac-连接越狱设备"><a href="#Mac-连接越狱设备" class="headerlink" title="Mac 连接越狱设备"></a>Mac 连接越狱设备</h4><p>通过 USB 将 Mac 和越狱设备连接，将 22 映射到 Mac 上的 2222 端口，打开 Mac 终端输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ iproxy 2222 22</span><br><span class="line">waiting for connection</span><br></pre></td></tr></table></figure><h4 id="查看应用列表"><a href="#查看应用列表" class="headerlink" title="查看应用列表"></a>查看应用列表</h4><p>再开一个终端窗口，输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ python dump.py -l</span><br><span class="line">  PID  Name                     Identifier</span><br><span class="line">-----  -----------------------  -------------------------------------</span><br><span class="line">12317  App Store                com.apple.AppStore</span><br><span class="line"> 4563  信息                       com.apple.MobileSMS</span><br><span class="line">12251  微信                       com.tencent.xin</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4 id="解密-2"><a href="#解密-2" class="headerlink" title="解密"></a>解密</h4><p>这里以微信为例，微信的包名为 com.tencent.xin</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python dump.py com.tencent.xin</span><br></pre></td></tr></table></figure><p>执行完毕，从 dump.py 同级别目录里获取砸完壳的 App</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结一下关于 iOS 砸壳的几种方式，方便以后查找，不定期更新…&lt;/p&gt;
    
    </summary>
    
    
      <category term="逆向" scheme="https://blog.zeinber.top/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="砸壳" scheme="https://blog.zeinber.top/tags/%E7%A0%B8%E5%A3%B3/"/>
    
  </entry>
  
</feed>
